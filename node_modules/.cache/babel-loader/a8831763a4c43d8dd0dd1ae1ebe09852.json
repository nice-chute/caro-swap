{"ast":null,"code":"import _slicedToArray from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = \"@@asyncIterator\", sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\n\nfunction AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function _return(value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function _throw(value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }\n\n/**\n * Body.js\n *\n * Body interface provides common methods for Request and Response\n */\nimport Stream, { PassThrough } from 'node:stream';\nimport { types, deprecate, promisify } from 'node:util';\nimport { Buffer } from 'node:buffer';\nimport Blob from 'fetch-blob';\nimport { FormData, formDataToBlob } from 'formdata-polyfill/esm.min.js';\nimport { FetchError } from './errors/fetch-error.js';\nimport { FetchBaseError } from './errors/base.js';\nimport { isBlob, isURLSearchParameters } from './utils/is.js';\nvar pipeline = promisify(Stream.pipeline);\nvar INTERNALS = Symbol('Body internals');\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\n\nvar Body = /*#__PURE__*/function () {\n  function Body(body) {\n    var _this = this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$size = _ref.size,\n        size = _ref$size === void 0 ? 0 : _ref$size;\n\n    _classCallCheck(this, Body);\n\n    var boundary = null;\n\n    if (body === null) {\n      // Body is undefined or null\n      body = null;\n    } else if (isURLSearchParameters(body)) {\n      // Body is a URLSearchParams\n      body = Buffer.from(body.toString());\n    } else if (isBlob(body)) {// Body is blob\n    } else if (Buffer.isBuffer(body)) {// Body is Buffer\n    } else if (types.isAnyArrayBuffer(body)) {\n      // Body is ArrayBuffer\n      body = Buffer.from(body);\n    } else if (ArrayBuffer.isView(body)) {\n      // Body is ArrayBufferView\n      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n    } else if (body instanceof Stream) {// Body is stream\n    } else if (body instanceof FormData) {\n      // Body is FormData\n      body = formDataToBlob(body);\n      boundary = body.type.split('=')[1];\n    } else {\n      // None of the above\n      // coerce to string then buffer\n      body = Buffer.from(String(body));\n    }\n\n    var stream = body;\n\n    if (Buffer.isBuffer(body)) {\n      stream = Stream.Readable.from(body);\n    } else if (isBlob(body)) {\n      stream = Stream.Readable.from(body.stream());\n    }\n\n    this[INTERNALS] = {\n      body: body,\n      stream: stream,\n      boundary: boundary,\n      disturbed: false,\n      error: null\n    };\n    this.size = size;\n\n    if (body instanceof Stream) {\n      body.on('error', function (error_) {\n        var error = error_ instanceof FetchBaseError ? error_ : new FetchError(\"Invalid response body while trying to fetch \".concat(_this.url, \": \").concat(error_.message), 'system', error_);\n        _this[INTERNALS].error = error;\n      });\n    }\n  }\n\n  _createClass(Body, [{\n    key: \"body\",\n    get: function get() {\n      return this[INTERNALS].stream;\n    }\n  }, {\n    key: \"bodyUsed\",\n    get: function get() {\n      return this[INTERNALS].disturbed;\n    }\n    /**\n     * Decode response as ArrayBuffer\n     *\n     * @return  Promise\n     */\n\n  }, {\n    key: \"arrayBuffer\",\n    value: function () {\n      var _arrayBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _yield$consumeBody, buffer, byteOffset, byteLength;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return consumeBody(this);\n\n              case 2:\n                _yield$consumeBody = _context.sent;\n                buffer = _yield$consumeBody.buffer;\n                byteOffset = _yield$consumeBody.byteOffset;\n                byteLength = _yield$consumeBody.byteLength;\n                return _context.abrupt(\"return\", buffer.slice(byteOffset, byteOffset + byteLength));\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function arrayBuffer() {\n        return _arrayBuffer.apply(this, arguments);\n      }\n\n      return arrayBuffer;\n    }()\n  }, {\n    key: \"formData\",\n    value: function () {\n      var _formData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var ct, _formData2, parameters, _iterator2, _step2, _step2$value, name, value, _yield$import, toFormData;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                ct = this.headers.get('content-type');\n\n                if (!ct.startsWith('application/x-www-form-urlencoded')) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                _formData2 = new FormData();\n                _context2.t0 = URLSearchParams;\n                _context2.next = 6;\n                return this.text();\n\n              case 6:\n                _context2.t1 = _context2.sent;\n                parameters = new _context2.t0(_context2.t1);\n                _iterator2 = _createForOfIteratorHelper(parameters);\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    _step2$value = _slicedToArray(_step2.value, 2), name = _step2$value[0], value = _step2$value[1];\n\n                    _formData2.append(name, value);\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                return _context2.abrupt(\"return\", _formData2);\n\n              case 11:\n                _context2.next = 13;\n                return import('./utils/multipart-parser.js');\n\n              case 13:\n                _yield$import = _context2.sent;\n                toFormData = _yield$import.toFormData;\n                return _context2.abrupt(\"return\", toFormData(this.body, ct));\n\n              case 16:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function formData() {\n        return _formData.apply(this, arguments);\n      }\n\n      return formData;\n    }()\n    /**\n     * Return raw response as Blob\n     *\n     * @return Promise\n     */\n\n  }, {\n    key: \"blob\",\n    value: function () {\n      var _blob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var ct, buf;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                ct = this.headers && this.headers.get('content-type') || this[INTERNALS].body && this[INTERNALS].body.type || '';\n                _context3.next = 3;\n                return this.arrayBuffer();\n\n              case 3:\n                buf = _context3.sent;\n                return _context3.abrupt(\"return\", new Blob([buf], {\n                  type: ct\n                }));\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function blob() {\n        return _blob.apply(this, arguments);\n      }\n\n      return blob;\n    }()\n    /**\n     * Decode response as json\n     *\n     * @return  Promise\n     */\n\n  }, {\n    key: \"json\",\n    value: function () {\n      var _json = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var buffer;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return consumeBody(this);\n\n              case 2:\n                buffer = _context4.sent;\n                return _context4.abrupt(\"return\", JSON.parse(buffer.toString()));\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function json() {\n        return _json.apply(this, arguments);\n      }\n\n      return json;\n    }()\n    /**\n     * Decode response as text\n     *\n     * @return  Promise\n     */\n\n  }, {\n    key: \"text\",\n    value: function () {\n      var _text = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var buffer;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return consumeBody(this);\n\n              case 2:\n                buffer = _context5.sent;\n                return _context5.abrupt(\"return\", buffer.toString());\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function text() {\n        return _text.apply(this, arguments);\n      }\n\n      return text;\n    }()\n    /**\n     * Decode response as buffer (non-spec api)\n     *\n     * @return  Promise\n     */\n\n  }, {\n    key: \"buffer\",\n    value: function buffer() {\n      return consumeBody(this);\n    }\n  }]);\n\n  return Body;\n}();\n\nexport { Body as default };\nBody.prototype.buffer = deprecate(Body.prototype.buffer, 'Please use \\'response.arrayBuffer()\\' instead of \\'response.buffer()\\'', 'node-fetch#buffer'); // In browsers, all properties are enumerable.\n\nObject.defineProperties(Body.prototype, {\n  body: {\n    enumerable: true\n  },\n  bodyUsed: {\n    enumerable: true\n  },\n  arrayBuffer: {\n    enumerable: true\n  },\n  blob: {\n    enumerable: true\n  },\n  json: {\n    enumerable: true\n  },\n  text: {\n    enumerable: true\n  },\n  data: {\n    get: deprecate(function () {}, 'data doesn\\'t exist, use json(), text(), arrayBuffer(), or body instead', 'https://github.com/node-fetch/node-fetch/issues/1000 (response)')\n  }\n});\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return Promise\n */\n\nfunction consumeBody(_x) {\n  return _consumeBody.apply(this, arguments);\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed   instance       Response or Request instance\n * @param   String  highWaterMark  highWaterMark for both PassThrough body streams\n * @return  Mixed\n */\n\n\nfunction _consumeBody() {\n  _consumeBody = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(data) {\n    var body, accum, accumBytes, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk, error, error_;\n\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            if (!data[INTERNALS].disturbed) {\n              _context7.next = 2;\n              break;\n            }\n\n            throw new TypeError(\"body used already for: \".concat(data.url));\n\n          case 2:\n            data[INTERNALS].disturbed = true;\n\n            if (!data[INTERNALS].error) {\n              _context7.next = 5;\n              break;\n            }\n\n            throw data[INTERNALS].error;\n\n          case 5:\n            body = data.body; // Body is null\n\n            if (!(body === null)) {\n              _context7.next = 8;\n              break;\n            }\n\n            return _context7.abrupt(\"return\", Buffer.alloc(0));\n\n          case 8:\n            if (body instanceof Stream) {\n              _context7.next = 10;\n              break;\n            }\n\n            return _context7.abrupt(\"return\", Buffer.alloc(0));\n\n          case 10:\n            // Body is stream\n            // get ready to actually consume the body\n            accum = [];\n            accumBytes = 0;\n            _context7.prev = 12;\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context7.prev = 15;\n            _iterator = _asyncIterator(body);\n\n          case 17:\n            _context7.next = 19;\n            return _iterator.next();\n\n          case 19:\n            if (!(_iteratorAbruptCompletion = !(_step = _context7.sent).done)) {\n              _context7.next = 30;\n              break;\n            }\n\n            chunk = _step.value;\n\n            if (!(data.size > 0 && accumBytes + chunk.length > data.size)) {\n              _context7.next = 25;\n              break;\n            }\n\n            error = new FetchError(\"content size at \".concat(data.url, \" over limit: \").concat(data.size), 'max-size');\n            body.destroy(error);\n            throw error;\n\n          case 25:\n            accumBytes += chunk.length;\n            accum.push(chunk);\n\n          case 27:\n            _iteratorAbruptCompletion = false;\n            _context7.next = 17;\n            break;\n\n          case 30:\n            _context7.next = 36;\n            break;\n\n          case 32:\n            _context7.prev = 32;\n            _context7.t0 = _context7[\"catch\"](15);\n            _didIteratorError = true;\n            _iteratorError = _context7.t0;\n\n          case 36:\n            _context7.prev = 36;\n            _context7.prev = 37;\n\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context7.next = 41;\n              break;\n            }\n\n            _context7.next = 41;\n            return _iterator.return();\n\n          case 41:\n            _context7.prev = 41;\n\n            if (!_didIteratorError) {\n              _context7.next = 44;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 44:\n            return _context7.finish(41);\n\n          case 45:\n            return _context7.finish(36);\n\n          case 46:\n            _context7.next = 52;\n            break;\n\n          case 48:\n            _context7.prev = 48;\n            _context7.t1 = _context7[\"catch\"](12);\n            error_ = _context7.t1 instanceof FetchBaseError ? _context7.t1 : new FetchError(\"Invalid response body while trying to fetch \".concat(data.url, \": \").concat(_context7.t1.message), 'system', _context7.t1);\n            throw error_;\n\n          case 52:\n            if (!(body.readableEnded === true || body._readableState.ended === true)) {\n              _context7.next = 64;\n              break;\n            }\n\n            _context7.prev = 53;\n\n            if (!accum.every(function (c) {\n              return typeof c === 'string';\n            })) {\n              _context7.next = 56;\n              break;\n            }\n\n            return _context7.abrupt(\"return\", Buffer.from(accum.join('')));\n\n          case 56:\n            return _context7.abrupt(\"return\", Buffer.concat(accum, accumBytes));\n\n          case 59:\n            _context7.prev = 59;\n            _context7.t2 = _context7[\"catch\"](53);\n            throw new FetchError(\"Could not create Buffer from response body for \".concat(data.url, \": \").concat(_context7.t2.message), 'system', _context7.t2);\n\n          case 62:\n            _context7.next = 65;\n            break;\n\n          case 64:\n            throw new FetchError(\"Premature close of server response while trying to fetch \".concat(data.url));\n\n          case 65:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7, null, [[12, 48], [15, 32, 36, 46], [37,, 41, 45], [53, 59]]);\n  }));\n  return _consumeBody.apply(this, arguments);\n}\n\nexport var clone = function clone(instance, highWaterMark) {\n  var p1;\n  var p2;\n  var body = instance[INTERNALS].body; // Don't allow cloning a used body\n\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used');\n  } // Check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n\n\n  if (body instanceof Stream && typeof body.getBoundary !== 'function') {\n    // Tee instance body\n    p1 = new PassThrough({\n      highWaterMark: highWaterMark\n    });\n    p2 = new PassThrough({\n      highWaterMark: highWaterMark\n    });\n    body.pipe(p1);\n    body.pipe(p2); // Set instance body to teed body and return the other teed body\n\n    instance[INTERNALS].stream = p1;\n    body = p2;\n  }\n\n  return body;\n};\nvar getNonSpecFormDataBoundary = deprecate(function (body) {\n  return body.getBoundary();\n}, 'form-data doesn\\'t follow the spec and requires special treatment. Use alternative package', 'https://github.com/node-fetch/node-fetch/issues/1167');\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param {any} body Any options.body input\n * @returns {string | null}\n */\n\nexport var extractContentType = function extractContentType(body, request) {\n  // Body is null or undefined\n  if (body === null) {\n    return null;\n  } // Body is string\n\n\n  if (typeof body === 'string') {\n    return 'text/plain;charset=UTF-8';\n  } // Body is a URLSearchParams\n\n\n  if (isURLSearchParameters(body)) {\n    return 'application/x-www-form-urlencoded;charset=UTF-8';\n  } // Body is blob\n\n\n  if (isBlob(body)) {\n    return body.type || null;\n  } // Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)\n\n\n  if (Buffer.isBuffer(body) || types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {\n    return null;\n  }\n\n  if (body instanceof FormData) {\n    return \"multipart/form-data; boundary=\".concat(request[INTERNALS].boundary);\n  } // Detect form data input from form-data module\n\n\n  if (body && typeof body.getBoundary === 'function') {\n    return \"multipart/form-data;boundary=\".concat(getNonSpecFormDataBoundary(body));\n  } // Body is stream - can't really do much about this\n\n\n  if (body instanceof Stream) {\n    return null;\n  } // Body constructor defaults other things to string\n\n\n  return 'text/plain;charset=UTF-8';\n};\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param {any} obj.body Body object from the Body instance.\n * @returns {number | null}\n */\n\nexport var getTotalBytes = function getTotalBytes(request) {\n  var body = request[INTERNALS].body; // Body is null or undefined\n\n  if (body === null) {\n    return 0;\n  } // Body is Blob\n\n\n  if (isBlob(body)) {\n    return body.size;\n  } // Body is Buffer\n\n\n  if (Buffer.isBuffer(body)) {\n    return body.length;\n  } // Detect form data input from form-data module\n\n\n  if (body && typeof body.getLengthSync === 'function') {\n    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;\n  } // Body is stream\n\n\n  return null;\n};\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param {Stream.Writable} dest The stream to write to.\n * @param obj.body Body object from the Body instance.\n * @returns {Promise<void>}\n */\n\nexport var writeToStream = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(dest, _ref2) {\n    var body;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            body = _ref2.body;\n\n            if (!(body === null)) {\n              _context6.next = 5;\n              break;\n            }\n\n            // Body is null\n            dest.end();\n            _context6.next = 7;\n            break;\n\n          case 5:\n            _context6.next = 7;\n            return pipeline(body, dest);\n\n          case 7:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function writeToStream(_x2, _x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _regeneratorRuntime from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = \"@@asyncIterator\", sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\n\nfunction AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function _return(value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function _throw(value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }\n\nimport { File } from 'fetch-blob/from.js';\nimport { FormData } from 'formdata-polyfill/esm.min.js';\nvar s = 0;\nvar S = {\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  END: s++\n};\nvar f = 1;\nvar F = {\n  PART_BOUNDARY: f,\n  LAST_BOUNDARY: f *= 2\n};\nvar LF = 10;\nvar CR = 13;\nvar SPACE = 32;\nvar HYPHEN = 45;\nvar COLON = 58;\nvar A = 97;\nvar Z = 122;\n\nvar lower = function lower(c) {\n  return c | 0x20;\n};\n\nvar noop = function noop() {};\n\nvar MultipartParser = /*#__PURE__*/function () {\n  /**\n   * @param {string} boundary\n   */\n  function MultipartParser(boundary) {\n    _classCallCheck(this, MultipartParser);\n\n    this.index = 0;\n    this.flags = 0;\n    this.onHeaderEnd = noop;\n    this.onHeaderField = noop;\n    this.onHeadersEnd = noop;\n    this.onHeaderValue = noop;\n    this.onPartBegin = noop;\n    this.onPartData = noop;\n    this.onPartEnd = noop;\n    this.boundaryChars = {};\n    boundary = '\\r\\n--' + boundary;\n    var ui8a = new Uint8Array(boundary.length);\n\n    for (var i = 0; i < boundary.length; i++) {\n      ui8a[i] = boundary.charCodeAt(i);\n      this.boundaryChars[ui8a[i]] = true;\n    }\n\n    this.boundary = ui8a;\n    this.lookbehind = new Uint8Array(this.boundary.length + 8);\n    this.state = S.START_BOUNDARY;\n  }\n  /**\n   * @param {Uint8Array} data\n   */\n\n\n  _createClass(MultipartParser, [{\n    key: \"write\",\n    value: function write(data) {\n      var _this = this;\n\n      var i = 0;\n      var length_ = data.length;\n      var previousIndex = this.index;\n      var lookbehind = this.lookbehind,\n          boundary = this.boundary,\n          boundaryChars = this.boundaryChars,\n          index = this.index,\n          state = this.state,\n          flags = this.flags;\n      var boundaryLength = this.boundary.length;\n      var boundaryEnd = boundaryLength - 1;\n      var bufferLength = data.length;\n      var c;\n      var cl;\n\n      var mark = function mark(name) {\n        _this[name + 'Mark'] = i;\n      };\n\n      var clear = function clear(name) {\n        delete _this[name + 'Mark'];\n      };\n\n      var callback = function callback(callbackSymbol, start, end, ui8a) {\n        if (start === undefined || start !== end) {\n          _this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n        }\n      };\n\n      var dataCallback = function dataCallback(name, clear) {\n        var markSymbol = name + 'Mark';\n\n        if (!(markSymbol in _this)) {\n          return;\n        }\n\n        if (clear) {\n          callback(name, _this[markSymbol], i, data);\n          delete _this[markSymbol];\n        } else {\n          callback(name, _this[markSymbol], data.length, data);\n          _this[markSymbol] = 0;\n        }\n      };\n\n      for (i = 0; i < length_; i++) {\n        c = data[i];\n\n        switch (state) {\n          case S.START_BOUNDARY:\n            if (index === boundary.length - 2) {\n              if (c === HYPHEN) {\n                flags |= F.LAST_BOUNDARY;\n              } else if (c !== CR) {\n                return;\n              }\n\n              index++;\n              break;\n            } else if (index - 1 === boundary.length - 2) {\n              if (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n                state = S.END;\n                flags = 0;\n              } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n                index = 0;\n                callback('onPartBegin');\n                state = S.HEADER_FIELD_START;\n              } else {\n                return;\n              }\n\n              break;\n            }\n\n            if (c !== boundary[index + 2]) {\n              index = -2;\n            }\n\n            if (c === boundary[index + 2]) {\n              index++;\n            }\n\n            break;\n\n          case S.HEADER_FIELD_START:\n            state = S.HEADER_FIELD;\n            mark('onHeaderField');\n            index = 0;\n          // falls through\n\n          case S.HEADER_FIELD:\n            if (c === CR) {\n              clear('onHeaderField');\n              state = S.HEADERS_ALMOST_DONE;\n              break;\n            }\n\n            index++;\n\n            if (c === HYPHEN) {\n              break;\n            }\n\n            if (c === COLON) {\n              if (index === 1) {\n                // empty header field\n                return;\n              }\n\n              dataCallback('onHeaderField', true);\n              state = S.HEADER_VALUE_START;\n              break;\n            }\n\n            cl = lower(c);\n\n            if (cl < A || cl > Z) {\n              return;\n            }\n\n            break;\n\n          case S.HEADER_VALUE_START:\n            if (c === SPACE) {\n              break;\n            }\n\n            mark('onHeaderValue');\n            state = S.HEADER_VALUE;\n          // falls through\n\n          case S.HEADER_VALUE:\n            if (c === CR) {\n              dataCallback('onHeaderValue', true);\n              callback('onHeaderEnd');\n              state = S.HEADER_VALUE_ALMOST_DONE;\n            }\n\n            break;\n\n          case S.HEADER_VALUE_ALMOST_DONE:\n            if (c !== LF) {\n              return;\n            }\n\n            state = S.HEADER_FIELD_START;\n            break;\n\n          case S.HEADERS_ALMOST_DONE:\n            if (c !== LF) {\n              return;\n            }\n\n            callback('onHeadersEnd');\n            state = S.PART_DATA_START;\n            break;\n\n          case S.PART_DATA_START:\n            state = S.PART_DATA;\n            mark('onPartData');\n          // falls through\n\n          case S.PART_DATA:\n            previousIndex = index;\n\n            if (index === 0) {\n              // boyer-moore derrived algorithm to safely skip non-boundary data\n              i += boundaryEnd;\n\n              while (i < bufferLength && !(data[i] in boundaryChars)) {\n                i += boundaryLength;\n              }\n\n              i -= boundaryEnd;\n              c = data[i];\n            }\n\n            if (index < boundary.length) {\n              if (boundary[index] === c) {\n                if (index === 0) {\n                  dataCallback('onPartData', true);\n                }\n\n                index++;\n              } else {\n                index = 0;\n              }\n            } else if (index === boundary.length) {\n              index++;\n\n              if (c === CR) {\n                // CR = part boundary\n                flags |= F.PART_BOUNDARY;\n              } else if (c === HYPHEN) {\n                // HYPHEN = end boundary\n                flags |= F.LAST_BOUNDARY;\n              } else {\n                index = 0;\n              }\n            } else if (index - 1 === boundary.length) {\n              if (flags & F.PART_BOUNDARY) {\n                index = 0;\n\n                if (c === LF) {\n                  // unset the PART_BOUNDARY flag\n                  flags &= ~F.PART_BOUNDARY;\n                  callback('onPartEnd');\n                  callback('onPartBegin');\n                  state = S.HEADER_FIELD_START;\n                  break;\n                }\n              } else if (flags & F.LAST_BOUNDARY) {\n                if (c === HYPHEN) {\n                  callback('onPartEnd');\n                  state = S.END;\n                  flags = 0;\n                } else {\n                  index = 0;\n                }\n              } else {\n                index = 0;\n              }\n            }\n\n            if (index > 0) {\n              // when matching a possible boundary, keep a lookbehind reference\n              // in case it turns out to be a false lead\n              lookbehind[index - 1] = c;\n            } else if (previousIndex > 0) {\n              // if our boundary turned out to be rubbish, the captured lookbehind\n              // belongs to partData\n              var _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\n              callback('onPartData', 0, previousIndex, _lookbehind);\n              previousIndex = 0;\n              mark('onPartData'); // reconsider the current character even so it interrupted the sequence\n              // it could be the beginning of a new sequence\n\n              i--;\n            }\n\n            break;\n\n          case S.END:\n            break;\n\n          default:\n            throw new Error(\"Unexpected state entered: \".concat(state));\n        }\n      }\n\n      dataCallback('onHeaderField');\n      dataCallback('onHeaderValue');\n      dataCallback('onPartData'); // Update properties for the next call\n\n      this.index = index;\n      this.state = state;\n      this.flags = flags;\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {\n        this.onPartEnd();\n      } else if (this.state !== S.END) {\n        throw new Error('MultipartParser.end(): stream ended unexpectedly');\n      }\n    }\n  }]);\n\n  return MultipartParser;\n}();\n\nfunction _fileName(headerValue) {\n  // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n  var m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\n  if (!m) {\n    return;\n  }\n\n  var match = m[2] || m[3] || '';\n  var filename = match.slice(match.lastIndexOf('\\\\') + 1);\n  filename = filename.replace(/%22/g, '\"');\n  filename = filename.replace(/&#(\\d{4});/g, function (m, code) {\n    return String.fromCharCode(code);\n  });\n  return filename;\n}\n\nexport function toFormData(_x, _x2) {\n  return _toFormData.apply(this, arguments);\n}\n\nfunction _toFormData() {\n  _toFormData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(Body, ct) {\n    var m, parser, headerField, headerValue, entryValue, entryName, contentType, filename, entryChunks, formData, onPartData, appendToFile, appendFileToFormData, appendEntryToFormData, decoder, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (/multipart/i.test(ct)) {\n              _context.next = 2;\n              break;\n            }\n\n            throw new TypeError('Failed to fetch');\n\n          case 2:\n            m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n            if (m) {\n              _context.next = 5;\n              break;\n            }\n\n            throw new TypeError('no or bad content-type header, no multipart boundary');\n\n          case 5:\n            parser = new MultipartParser(m[1] || m[2]);\n            entryChunks = [];\n            formData = new FormData();\n\n            onPartData = function onPartData(ui8a) {\n              entryValue += decoder.decode(ui8a, {\n                stream: true\n              });\n            };\n\n            appendToFile = function appendToFile(ui8a) {\n              entryChunks.push(ui8a);\n            };\n\n            appendFileToFormData = function appendFileToFormData() {\n              var file = new File(entryChunks, filename, {\n                type: contentType\n              });\n              formData.append(entryName, file);\n            };\n\n            appendEntryToFormData = function appendEntryToFormData() {\n              formData.append(entryName, entryValue);\n            };\n\n            decoder = new TextDecoder('utf-8');\n            decoder.decode();\n\n            parser.onPartBegin = function () {\n              parser.onPartData = onPartData;\n              parser.onPartEnd = appendEntryToFormData;\n              headerField = '';\n              headerValue = '';\n              entryValue = '';\n              entryName = '';\n              contentType = '';\n              filename = null;\n              entryChunks.length = 0;\n            };\n\n            parser.onHeaderField = function (ui8a) {\n              headerField += decoder.decode(ui8a, {\n                stream: true\n              });\n            };\n\n            parser.onHeaderValue = function (ui8a) {\n              headerValue += decoder.decode(ui8a, {\n                stream: true\n              });\n            };\n\n            parser.onHeaderEnd = function () {\n              headerValue += decoder.decode();\n              headerField = headerField.toLowerCase();\n\n              if (headerField === 'content-disposition') {\n                // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n                var _m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n                if (_m) {\n                  entryName = _m[2] || _m[3] || '';\n                }\n\n                filename = _fileName(headerValue);\n\n                if (filename) {\n                  parser.onPartData = appendToFile;\n                  parser.onPartEnd = appendFileToFormData;\n                }\n              } else if (headerField === 'content-type') {\n                contentType = headerValue;\n              }\n\n              headerValue = '';\n              headerField = '';\n            };\n\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context.prev = 20;\n            _iterator = _asyncIterator(Body);\n\n          case 22:\n            _context.next = 24;\n            return _iterator.next();\n\n          case 24:\n            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n              _context.next = 30;\n              break;\n            }\n\n            chunk = _step.value;\n            parser.write(chunk);\n\n          case 27:\n            _iteratorAbruptCompletion = false;\n            _context.next = 22;\n            break;\n\n          case 30:\n            _context.next = 36;\n            break;\n\n          case 32:\n            _context.prev = 32;\n            _context.t0 = _context[\"catch\"](20);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n\n          case 36:\n            _context.prev = 36;\n            _context.prev = 37;\n\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context.next = 41;\n              break;\n            }\n\n            _context.next = 41;\n            return _iterator.return();\n\n          case 41:\n            _context.prev = 41;\n\n            if (!_didIteratorError) {\n              _context.next = 44;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 44:\n            return _context.finish(41);\n\n          case 45:\n            return _context.finish(36);\n\n          case 46:\n            parser.end();\n            return _context.abrupt(\"return\", formData);\n\n          case 48:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[20, 32, 36, 46], [37,, 41, 45]]);\n  }));\n  return _toFormData.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}
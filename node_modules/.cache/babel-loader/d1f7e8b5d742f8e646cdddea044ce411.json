{"ast":null,"code":"import _inherits from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _slicedToArray from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/daniel/dev/caroline-swap/app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport axios from 'axios';\nimport { clusterApiUrl, Connection as Connection$1, SystemProgram, PublicKey, TransactionInstruction, SYSVAR_RENT_PUBKEY, Keypair, Transaction as Transaction$1 } from '@solana/web3.js';\nimport { sha256 } from 'crypto-hash';\nimport { Buffer as Buffer$1 } from 'buffer';\nimport { MintLayout, TOKEN_PROGRAM_ID, Token, AccountLayout, ASSOCIATED_TOKEN_PROGRAM_ID, NATIVE_MINT } from '@solana/spl-token';\nimport * as mplTokenVault from '@metaplex-foundation/mpl-token-vault';\nimport { Vault, SafetyDepositBox, AddTokenToInactiveVault, ActivateVault, CombineVault, ExternalPriceAccountData, VaultProgram, UpdateExternalPriceAccount, InitVault } from '@metaplex-foundation/mpl-token-vault';\nimport * as mplCore from '@metaplex-foundation/mpl-core';\nimport { Transaction, config, Account } from '@metaplex-foundation/mpl-core';\nimport BN from 'bn.js';\nimport * as mplMetaplex from '@metaplex-foundation/mpl-metaplex';\nimport { Store, SetStore, StoreConfig, SetStoreV2, AuctionManager, MetaplexProgram, SafetyDepositConfig, RedeemFullRightsTransferBid, PrizeTrackingTicket, RedeemPrintingV2Bid, RedeemParticipationBidV3, WinningConstraint, NonWinningConstraint, ClaimBid, WinningConfigType } from '@metaplex-foundation/mpl-metaplex';\nimport * as mplTokenMetadata from '@metaplex-foundation/mpl-token-metadata';\nimport { Metadata, MasterEdition, Creator, MetadataDataData, CreateMetadata, CreateMasterEdition, EditionMarker, Edition, MintNewEditionFromMasterEditionViaToken, SignMetadata, UpdateMetadata, UpdatePrimarySaleHappenedViaToken } from '@metaplex-foundation/mpl-token-metadata';\nimport * as mplAuction from '@metaplex-foundation/mpl-auction';\nimport { AuctionExtended, BidderPot, BidderMetadata, CancelBid, PlaceBid, Auction, CreateAuctionArgs, CreateAuction } from '@metaplex-foundation/mpl-auction';\nvar Currency;\n\n(function (Currency) {\n  Currency[\"USD\"] = \"usd\";\n  Currency[\"EUR\"] = \"eur\";\n  Currency[\"AR\"] = \"ar\";\n  Currency[\"SOL\"] = \"sol\";\n})(Currency || (Currency = {}));\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nvar Coingecko = /*#__PURE__*/function () {\n  function Coingecko() {\n    _classCallCheck(this, Coingecko);\n  }\n\n  _createClass(Coingecko, [{\n    key: \"getRate\",\n    value: function getRate(from, to) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var fromArray, toArray, fromIds, toIds, url, response, data;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                fromArray = typeof from === 'string' ? [from] : from;\n                toArray = typeof to === 'string' ? [to] : to;\n                fromIds = fromArray.map(function (currency) {\n                  return Coingecko.translateCurrency(currency);\n                }).join(',');\n                toIds = toArray.map(function (currency) {\n                  return Coingecko.translateCurrency(currency);\n                }).join(',');\n                url = \"https://api.coingecko.com/api/v3/simple/price?ids=\".concat(fromIds, \"&vs_currencies=\").concat(toIds);\n                _context.next = 7;\n                return axios(url);\n\n              case 7:\n                response = _context.sent;\n                _context.next = 10;\n                return response.data;\n\n              case 10:\n                data = _context.sent;\n                return _context.abrupt(\"return\", fromArray.reduce(function (previousPairs, fromCurrency) {\n                  return [].concat(_toConsumableArray(previousPairs), _toConsumableArray(toArray.map(function (toCurrency) {\n                    return {\n                      from: fromCurrency,\n                      to: toCurrency,\n                      rate: data[Coingecko.translateCurrency(fromCurrency)][Coingecko.translateCurrency(toCurrency)]\n                    };\n                  })));\n                }, []));\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    }\n  }], [{\n    key: \"translateCurrency\",\n    value: function translateCurrency(currency) {\n      switch (currency) {\n        case Currency.AR:\n          return 'arweave';\n\n        case Currency.SOL:\n          return 'solana';\n\n        case Currency.USD:\n          return 'usd';\n\n        case Currency.EUR:\n          return 'eur';\n\n        default:\n          throw new Error('Invalid currency supplied to Coingecko conversion rate provider');\n      }\n    }\n  }]);\n\n  return Coingecko;\n}();\n/* eslint-env browser */\n\n\nvar browser = typeof self == 'object' ? self.FormData : window.FormData;\nvar ARWEAVE_URL = 'https://arweave.net';\nvar LAMPORT_MULTIPLIER = Math.pow(10, 9);\nvar WINSTON_MULTIPLIER = Math.pow(10, 12);\n\nvar ArweaveStorage = /*#__PURE__*/function () {\n  function ArweaveStorage(_ref) {\n    var endpoint = _ref.endpoint,\n        env = _ref.env;\n\n    _classCallCheck(this, ArweaveStorage);\n\n    this.endpoint = endpoint;\n    this.env = env;\n  }\n\n  _createClass(ArweaveStorage, [{\n    key: \"getAssetCostToStore\",\n    value: function getAssetCostToStore(files, arweaveRate, solanaRate) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var buffers, totalBytes, txnFeeInWinstons, byteCostInWinstons, totalArCost, arMultiplier;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                buffers = Array.from(files.values());\n                totalBytes = buffers.reduce(function (sum, f) {\n                  return sum += f.byteLength;\n                }, 0);\n                _context2.t0 = parseInt;\n                _context2.next = 5;\n                return axios(\"\".concat(ARWEAVE_URL, \"/price/0\"));\n\n              case 5:\n                _context2.next = 7;\n                return _context2.sent.data;\n\n              case 7:\n                _context2.t1 = _context2.sent;\n                txnFeeInWinstons = (0, _context2.t0)(_context2.t1);\n                _context2.t2 = parseInt;\n                _context2.next = 12;\n                return axios(\"\".concat(ARWEAVE_URL, \"/price/\").concat(totalBytes.toString()));\n\n              case 12:\n                _context2.next = 14;\n                return _context2.sent.data;\n\n              case 14:\n                _context2.t3 = _context2.sent;\n                byteCostInWinstons = (0, _context2.t2)(_context2.t3);\n                totalArCost = (txnFeeInWinstons * buffers.length + byteCostInWinstons) / WINSTON_MULTIPLIER;\n                arMultiplier = arweaveRate / solanaRate;\n                return _context2.abrupt(\"return\", LAMPORT_MULTIPLIER * totalArCost * arMultiplier * 1.1);\n\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n    }\n  }, {\n    key: \"upload\",\n    value: function upload(files, mintKey, txid) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var fileEntries, tags, body, response;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                fileEntries = Array.from(files.entries());\n                tags = fileEntries.reduce(function (acc, _ref2) {\n                  var _ref3 = _slicedToArray(_ref2, 1),\n                      fileName = _ref3[0];\n\n                  acc[fileName] = [{\n                    name: 'mint',\n                    value: mintKey\n                  }];\n                  return acc;\n                }, {});\n                body = new browser();\n                body.append('tags', JSON.stringify(tags));\n                body.append('transaction', txid);\n                body.append('env', this.env);\n                fileEntries.map(function (_ref4) {\n                  var _ref5 = _slicedToArray(_ref4, 2),\n                      file = _ref5[1];\n\n                  body.append('file[]', file);\n                });\n                _context3.next = 9;\n                return axios.post(this.endpoint, body);\n\n              case 9:\n                response = _context3.sent;\n\n                if (!response.data.error) {\n                  _context3.next = 12;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", Promise.reject(new Error(response.data.error)));\n\n              case 12:\n                return _context3.abrupt(\"return\", response.data);\n\n              case 13:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }]);\n\n  return ArweaveStorage;\n}();\n\nvar Storage = /*#__PURE__*/_createClass(function Storage() {\n  _classCallCheck(this, Storage);\n});\n\nvar Storage$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Storage: Storage\n});\nvar ChainId;\n\n(function (ChainId) {\n  ChainId[ChainId[\"MainnetBeta\"] = 101] = \"MainnetBeta\";\n  ChainId[ChainId[\"Testnet\"] = 102] = \"Testnet\";\n  ChainId[ChainId[\"Devnet\"] = 103] = \"Devnet\";\n})(ChainId || (ChainId = {}));\n\nvar ENV = {\n  devnet: {\n    endpoint: clusterApiUrl('devnet'),\n    ChainId: ChainId.Devnet\n  },\n  'mainnet-beta': {\n    endpoint: 'https://api.metaplex.solana.com/',\n    ChainId: ChainId.MainnetBeta\n  },\n  'mainnet-beta (Solana)': {\n    endpoint: 'https://api.mainnet-beta.solana.com',\n    ChainId: ChainId.MainnetBeta\n  },\n  'mainnet-beta (Serum)': {\n    endpoint: 'https://solana-api.projectserum.com/',\n    ChainId: ChainId.MainnetBeta\n  },\n  testnet: {\n    endpoint: clusterApiUrl('testnet'),\n    ChainId: ChainId.Testnet\n  }\n};\n\nvar Connection = /*#__PURE__*/function (_Connection$) {\n  _inherits(Connection, _Connection$);\n\n  var _super = _createSuper(Connection);\n\n  function Connection() {\n    var endpoint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'mainnet-beta';\n    var commitment = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck(this, Connection);\n\n    if (endpoint in ENV) endpoint = ENV[endpoint].endpoint;\n    return _super.call(this, endpoint, commitment);\n  }\n\n  return _createClass(Connection);\n}(Connection$1);\n\nvar NodeWallet = /*#__PURE__*/function () {\n  function NodeWallet(payer) {\n    _classCallCheck(this, NodeWallet);\n\n    this.payer = payer;\n  }\n\n  _createClass(NodeWallet, [{\n    key: \"signTransaction\",\n    value: function signTransaction(tx) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                tx.partialSign(this.payer);\n                return _context4.abrupt(\"return\", tx);\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"signAllTransactions\",\n    value: function signAllTransactions(txs) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", txs.map(function (tx) {\n                  tx.partialSign(_this.payer);\n                  return tx;\n                }));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n    }\n  }, {\n    key: \"publicKey\",\n    get: function get() {\n      return this.payer.publicKey;\n    }\n  }]);\n\n  return NodeWallet;\n}();\n\nvar getFileHash = function getFileHash(file) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.t0 = Buffer$1;\n            _context6.next = 3;\n            return sha256(file.toString());\n\n          case 3:\n            _context6.t1 = _context6.sent;\n            return _context6.abrupt(\"return\", _context6.t0.from.call(_context6.t0, _context6.t1));\n\n          case 5:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n};\n\nvar crypto = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getFileHash: getFileHash\n});\n\nvar lookup = function lookup(url) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n    var _yield$axios$get, data;\n\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.prev = 0;\n            _context7.next = 3;\n            return axios.get(url);\n\n          case 3:\n            _yield$axios$get = _context7.sent;\n            data = _yield$axios$get.data;\n            return _context7.abrupt(\"return\", data);\n\n          case 8:\n            _context7.prev = 8;\n            _context7.t0 = _context7[\"catch\"](0);\n            throw new Error(\"unable to get metadata json from url \".concat(url));\n\n          case 11:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7, null, [[0, 8]]);\n  }));\n};\n\nvar metadata = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  lookup: lookup\n});\nvar index$3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Crypto: crypto,\n  metadata: metadata\n});\n\nvar PayForFiles = /*#__PURE__*/function (_Transaction) {\n  _inherits(PayForFiles, _Transaction);\n\n  var _super2 = _createSuper(PayForFiles);\n\n  function PayForFiles(options, params) {\n    var _this2;\n\n    _classCallCheck(this, PayForFiles);\n\n    var feePayer = options.feePayer;\n    var lamports = params.lamports,\n        fileHashes = params.fileHashes,\n        arweaveWallet = params.arweaveWallet;\n    _this2 = _super2.call(this, options);\n\n    _this2.add(SystemProgram.transfer({\n      fromPubkey: feePayer,\n      toPubkey: arweaveWallet !== null && arweaveWallet !== void 0 ? arweaveWallet : new PublicKey(config.arweaveWallet),\n      lamports: lamports\n    }));\n\n    fileHashes.forEach(function (data) {\n      _this2.add(new TransactionInstruction({\n        keys: [],\n        programId: new PublicKey(config.programs.memo),\n        data: data\n      }));\n    });\n    return _this2;\n  }\n\n  return _createClass(PayForFiles);\n}(Transaction);\n\nvar CreateMint = /*#__PURE__*/function (_Transaction2) {\n  _inherits(CreateMint, _Transaction2);\n\n  var _super3 = _createSuper(CreateMint);\n\n  function CreateMint(options, params) {\n    var _this3;\n\n    _classCallCheck(this, CreateMint);\n\n    var feePayer = options.feePayer;\n    var newAccountPubkey = params.newAccountPubkey,\n        lamports = params.lamports,\n        decimals = params.decimals,\n        owner = params.owner,\n        freezeAuthority = params.freezeAuthority;\n    _this3 = _super3.call(this, options);\n\n    _this3.add(SystemProgram.createAccount({\n      fromPubkey: feePayer,\n      newAccountPubkey: newAccountPubkey,\n      lamports: lamports,\n      space: MintLayout.span,\n      programId: TOKEN_PROGRAM_ID\n    }));\n\n    _this3.add(Token.createInitMintInstruction(TOKEN_PROGRAM_ID, newAccountPubkey, decimals !== null && decimals !== void 0 ? decimals : 0, owner !== null && owner !== void 0 ? owner : feePayer, freezeAuthority !== null && freezeAuthority !== void 0 ? freezeAuthority : feePayer));\n\n    return _this3;\n  }\n\n  return _createClass(CreateMint);\n}(Transaction);\n\nvar CreateTokenAccount = /*#__PURE__*/function (_Transaction3) {\n  _inherits(CreateTokenAccount, _Transaction3);\n\n  var _super4 = _createSuper(CreateTokenAccount);\n\n  function CreateTokenAccount(options, params) {\n    var _this4;\n\n    _classCallCheck(this, CreateTokenAccount);\n\n    var feePayer = options.feePayer;\n    var newAccountPubkey = params.newAccountPubkey,\n        lamports = params.lamports,\n        mint = params.mint,\n        owner = params.owner;\n    _this4 = _super4.call(this, options);\n\n    _this4.add(SystemProgram.createAccount({\n      fromPubkey: feePayer,\n      newAccountPubkey: newAccountPubkey,\n      lamports: lamports,\n      space: AccountLayout.span,\n      programId: TOKEN_PROGRAM_ID\n    }));\n\n    _this4.add(Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, newAccountPubkey, owner !== null && owner !== void 0 ? owner : feePayer));\n\n    return _this4;\n  }\n\n  return _createClass(CreateTokenAccount);\n}(Transaction);\n\nvar CreateAssociatedTokenAccount = /*#__PURE__*/function (_Transaction4) {\n  _inherits(CreateAssociatedTokenAccount, _Transaction4);\n\n  var _super5 = _createSuper(CreateAssociatedTokenAccount);\n\n  function CreateAssociatedTokenAccount(options, params) {\n    var _this5;\n\n    _classCallCheck(this, CreateAssociatedTokenAccount);\n\n    var feePayer = options.feePayer;\n    var associatedTokenAddress = params.associatedTokenAddress,\n        walletAddress = params.walletAddress,\n        splTokenMintAddress = params.splTokenMintAddress;\n    _this5 = _super5.call(this, options);\n\n    _this5.add(new TransactionInstruction({\n      keys: [{\n        pubkey: feePayer,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: associatedTokenAddress,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: walletAddress !== null && walletAddress !== void 0 ? walletAddress : feePayer,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: splTokenMintAddress,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: TOKEN_PROGRAM_ID,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: ASSOCIATED_TOKEN_PROGRAM_ID,\n      data: Buffer$1.from([])\n    }));\n\n    return _this5;\n  }\n\n  return _createClass(CreateAssociatedTokenAccount);\n}(Transaction);\n\nvar MintTo = /*#__PURE__*/function (_Transaction5) {\n  _inherits(MintTo, _Transaction5);\n\n  var _super6 = _createSuper(MintTo);\n\n  function MintTo(options, params) {\n    var _this6;\n\n    _classCallCheck(this, MintTo);\n\n    var feePayer = options.feePayer;\n    var mint = params.mint,\n        dest = params.dest,\n        authority = params.authority,\n        amount = params.amount;\n    _this6 = _super6.call(this, options);\n\n    _this6.add(Token.createMintToInstruction(TOKEN_PROGRAM_ID, mint, dest, authority !== null && authority !== void 0 ? authority : feePayer, [], new BN(amount).toNumber()));\n\n    return _this6;\n  }\n\n  return _createClass(MintTo);\n}(Transaction);\n\nvar index$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  PayForFiles: PayForFiles,\n  CreateMint: CreateMint,\n  CreateTokenAccount: CreateTokenAccount,\n  CreateAssociatedTokenAccount: CreateAssociatedTokenAccount,\n  MintTo: MintTo\n});\n\nfunction prepareTokenAccountAndMintTxs(connection, owner) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n    var mint, mintRent, createMintTx, recipient, createAssociatedTokenAccountTx, mintToTx;\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            mint = Keypair.generate();\n            _context8.next = 3;\n            return connection.getMinimumBalanceForRentExemption(MintLayout.span);\n\n          case 3:\n            mintRent = _context8.sent;\n            createMintTx = new CreateMint({\n              feePayer: owner\n            }, {\n              newAccountPubkey: mint.publicKey,\n              lamports: mintRent\n            });\n            _context8.next = 7;\n            return Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mint.publicKey, owner);\n\n          case 7:\n            recipient = _context8.sent;\n            createAssociatedTokenAccountTx = new CreateAssociatedTokenAccount({\n              feePayer: owner\n            }, {\n              associatedTokenAddress: recipient,\n              splTokenMintAddress: mint.publicKey\n            });\n            mintToTx = new MintTo({\n              feePayer: owner\n            }, {\n              mint: mint.publicKey,\n              dest: recipient,\n              amount: 1\n            });\n            return _context8.abrupt(\"return\", {\n              mint: mint,\n              createMintTx: createMintTx,\n              createAssociatedTokenAccountTx: createAssociatedTokenAccountTx,\n              mintToTx: mintToTx,\n              recipient: recipient\n            });\n\n          case 11:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n}\n\nfunction createWrappedAccountTxs(connection, owner) {\n  var amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n    var account, accountRentExempt, createTokenAccountTx, closeTokenAccountTx;\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            account = Keypair.generate();\n            _context9.next = 3;\n            return connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n\n          case 3:\n            accountRentExempt = _context9.sent;\n            createTokenAccountTx = new CreateTokenAccount({\n              feePayer: owner\n            }, {\n              newAccountPubkey: account.publicKey,\n              lamports: amount + accountRentExempt,\n              mint: NATIVE_MINT\n            });\n            closeTokenAccountTx = new Transaction().add(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, account.publicKey, owner, owner, []));\n            return _context9.abrupt(\"return\", {\n              account: account,\n              createTokenAccountTx: createTokenAccountTx,\n              closeTokenAccountTx: closeTokenAccountTx\n            });\n\n          case 7:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n}\n\nfunction createApproveTxs(args) {\n  var _args$authority = args.authority,\n      authority = _args$authority === void 0 ? Keypair.generate() : _args$authority,\n      account = args.account,\n      owner = args.owner,\n      amount = args.amount;\n  var createApproveTx = new Transaction$1().add(Token.createApproveInstruction(TOKEN_PROGRAM_ID, account, authority.publicKey, owner, [], amount));\n  var createRevokeTx = new Transaction$1().add(Token.createRevokeInstruction(TOKEN_PROGRAM_ID, account, owner, []));\n  return {\n    authority: authority,\n    createApproveTx: createApproveTx,\n    createRevokeTx: createRevokeTx\n  };\n}\n\nvar sendTransaction = function sendTransaction(_ref6) {\n  var connection = _ref6.connection,\n      wallet = _ref6.wallet,\n      txs = _ref6.txs,\n      _ref6$signers = _ref6.signers,\n      signers = _ref6$signers === void 0 ? [] : _ref6$signers,\n      options = _ref6.options;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n    var tx, _tx;\n\n    return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            tx = Transaction.fromCombined(txs, {\n              feePayer: wallet.publicKey\n            });\n            _context10.next = 3;\n            return connection.getRecentBlockhash();\n\n          case 3:\n            tx.recentBlockhash = _context10.sent.blockhash;\n\n            if (signers.length) {\n              (_tx = tx).partialSign.apply(_tx, _toConsumableArray(signers));\n            }\n\n            _context10.next = 7;\n            return wallet.signTransaction(tx);\n\n          case 7:\n            tx = _context10.sent;\n            return _context10.abrupt(\"return\", connection.sendRawTransaction(tx.serialize(), options));\n\n          case 9:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n};\n\nvar TransactionsBatch = /*#__PURE__*/function () {\n  function TransactionsBatch(_ref7) {\n    var _ref7$beforeTransacti = _ref7.beforeTransactions,\n        beforeTransactions = _ref7$beforeTransacti === void 0 ? [] : _ref7$beforeTransacti,\n        transactions = _ref7.transactions,\n        _ref7$afterTransactio = _ref7.afterTransactions,\n        afterTransactions = _ref7$afterTransactio === void 0 ? [] : _ref7$afterTransactio;\n\n    _classCallCheck(this, TransactionsBatch);\n\n    this.signers = [];\n    this.beforeTransactions = beforeTransactions;\n    this.transactions = transactions;\n    this.afterTransactions = afterTransactions;\n  }\n\n  _createClass(TransactionsBatch, [{\n    key: \"addSigner\",\n    value: function addSigner(signer) {\n      this.signers.push(signer);\n    }\n  }, {\n    key: \"addBeforeTransaction\",\n    value: function addBeforeTransaction(transaction) {\n      this.beforeTransactions.push(transaction);\n    }\n  }, {\n    key: \"addTransaction\",\n    value: function addTransaction(transaction) {\n      this.transactions.push(transaction);\n    }\n  }, {\n    key: \"addAfterTransaction\",\n    value: function addAfterTransaction(transaction) {\n      this.afterTransactions.push(transaction);\n    }\n  }, {\n    key: \"toTransactions\",\n    value: function toTransactions() {\n      return [].concat(_toConsumableArray(this.beforeTransactions), _toConsumableArray(this.transactions), _toConsumableArray(this.afterTransactions));\n    }\n  }, {\n    key: \"toInstructions\",\n    value: function toInstructions() {\n      return this.toTransactions().flatMap(function (t) {\n        return t.instructions;\n      });\n    }\n  }]);\n\n  return TransactionsBatch;\n}();\n\nvar addTokensToVault = function addTokensToVault(_ref8) {\n  var connection = _ref8.connection,\n      wallet = _ref8.wallet,\n      vault = _ref8.vault,\n      nfts = _ref8.nfts;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n    var txOptions, safetyDepositTokenStores, vaultAuthority, accountRent, _iterator, _step, nft, tokenTxBatch, safetyDepositBox, tokenStoreAccount, tokenStoreAccountTx, _createApproveTxs, transferAuthority, createApproveTx, addTokenTx, txId;\n\n    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            txOptions = {\n              feePayer: wallet.publicKey\n            };\n            safetyDepositTokenStores = [];\n            _context11.next = 4;\n            return Vault.getPDA(vault);\n\n          case 4:\n            vaultAuthority = _context11.sent;\n            _context11.next = 7;\n            return connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n\n          case 7:\n            accountRent = _context11.sent;\n            _iterator = _createForOfIteratorHelper(nfts);\n            _context11.prev = 9;\n\n            _iterator.s();\n\n          case 11:\n            if ((_step = _iterator.n()).done) {\n              _context11.next = 32;\n              break;\n            }\n\n            nft = _step.value;\n            tokenTxBatch = new TransactionsBatch({\n              transactions: []\n            });\n            _context11.next = 16;\n            return SafetyDepositBox.getPDA(vault, nft.tokenMint);\n\n          case 16:\n            safetyDepositBox = _context11.sent;\n            tokenStoreAccount = Keypair.generate();\n            tokenStoreAccountTx = new CreateTokenAccount(txOptions, {\n              newAccountPubkey: tokenStoreAccount.publicKey,\n              lamports: accountRent,\n              mint: nft.tokenMint,\n              owner: vaultAuthority\n            });\n            tokenTxBatch.addTransaction(tokenStoreAccountTx);\n            tokenTxBatch.addSigner(tokenStoreAccount);\n            _createApproveTxs = createApproveTxs({\n              account: nft.tokenAccount,\n              owner: wallet.publicKey,\n              amount: nft.amount.toNumber()\n            }), transferAuthority = _createApproveTxs.authority, createApproveTx = _createApproveTxs.createApproveTx;\n            tokenTxBatch.addTransaction(createApproveTx);\n            tokenTxBatch.addSigner(transferAuthority);\n            addTokenTx = new AddTokenToInactiveVault(txOptions, {\n              vault: vault,\n              vaultAuthority: wallet.publicKey,\n              tokenAccount: nft.tokenAccount,\n              tokenStoreAccount: tokenStoreAccount.publicKey,\n              transferAuthority: transferAuthority.publicKey,\n              safetyDepositBox: safetyDepositBox,\n              amount: nft.amount\n            });\n            tokenTxBatch.addTransaction(addTokenTx);\n            _context11.next = 28;\n            return sendTransaction({\n              connection: connection,\n              wallet: wallet,\n              txs: tokenTxBatch.transactions,\n              signers: tokenTxBatch.signers\n            });\n\n          case 28:\n            txId = _context11.sent;\n            safetyDepositTokenStores.push({\n              txId: txId,\n              tokenStoreAccount: tokenStoreAccount.publicKey,\n              tokenMint: nft.tokenMint,\n              tokenAccount: nft.tokenAccount\n            });\n\n          case 30:\n            _context11.next = 11;\n            break;\n\n          case 32:\n            _context11.next = 37;\n            break;\n\n          case 34:\n            _context11.prev = 34;\n            _context11.t0 = _context11[\"catch\"](9);\n\n            _iterator.e(_context11.t0);\n\n          case 37:\n            _context11.prev = 37;\n\n            _iterator.f();\n\n            return _context11.finish(37);\n\n          case 40:\n            return _context11.abrupt(\"return\", {\n              safetyDepositTokenStores: safetyDepositTokenStores\n            });\n\n          case 41:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11, null, [[9, 34, 37, 40]]);\n  }));\n};\n\nvar initStore = function initStore(_ref9) {\n  var connection = _ref9.connection,\n      wallet = _ref9.wallet,\n      _ref9$isPublic = _ref9.isPublic,\n      isPublic = _ref9$isPublic === void 0 ? true : _ref9$isPublic;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n    var storeId, tx, txId;\n    return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            _context12.next = 2;\n            return Store.getPDA(wallet.publicKey);\n\n          case 2:\n            storeId = _context12.sent;\n            tx = new SetStore({\n              feePayer: wallet.publicKey\n            }, {\n              admin: new PublicKey(wallet.publicKey),\n              store: storeId,\n              isPublic: isPublic\n            });\n            _context12.next = 6;\n            return sendTransaction({\n              connection: connection,\n              wallet: wallet,\n              txs: [tx]\n            });\n\n          case 6:\n            txId = _context12.sent;\n            return _context12.abrupt(\"return\", {\n              storeId: storeId,\n              txId: txId\n            });\n\n          case 8:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, _callee12);\n  }));\n};\n\nvar initStoreV2 = function initStoreV2(_ref10) {\n  var connection = _ref10.connection,\n      wallet = _ref10.wallet,\n      _ref10$settingsUri = _ref10.settingsUri,\n      settingsUri = _ref10$settingsUri === void 0 ? null : _ref10$settingsUri,\n      _ref10$isPublic = _ref10.isPublic,\n      isPublic = _ref10$isPublic === void 0 ? true : _ref10$isPublic;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n    var storeId, configId, tx, txId;\n    return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            _context13.next = 2;\n            return Store.getPDA(wallet.publicKey);\n\n          case 2:\n            storeId = _context13.sent;\n            _context13.next = 5;\n            return StoreConfig.getPDA(storeId);\n\n          case 5:\n            configId = _context13.sent;\n            tx = new SetStoreV2({\n              feePayer: wallet.publicKey\n            }, {\n              admin: new PublicKey(wallet.publicKey),\n              store: storeId,\n              config: configId,\n              isPublic: isPublic,\n              settingsUri: settingsUri\n            });\n            _context13.next = 9;\n            return sendTransaction({\n              connection: connection,\n              wallet: wallet,\n              txs: [tx]\n            });\n\n          case 9:\n            txId = _context13.sent;\n            return _context13.abrupt(\"return\", {\n              storeId: storeId,\n              configId: configId,\n              txId: txId\n            });\n\n          case 11:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n};\n\nvar mintNFT = function mintNFT(_ref11) {\n  var connection = _ref11.connection,\n      wallet = _ref11.wallet,\n      uri = _ref11.uri,\n      maxSupply = _ref11.maxSupply;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n    var _yield$prepareTokenAc, mint, createMintTx, createAssociatedTokenAccountTx, mintToTx, metadataPDA, editionPDA, _yield$lookup, name, symbol, seller_fee_basis_points, creators, creatorsData, metadataData, createMetadataTx, masterEditionTx, txId;\n\n    return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            _context14.next = 2;\n            return prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\n\n          case 2:\n            _yield$prepareTokenAc = _context14.sent;\n            mint = _yield$prepareTokenAc.mint;\n            createMintTx = _yield$prepareTokenAc.createMintTx;\n            createAssociatedTokenAccountTx = _yield$prepareTokenAc.createAssociatedTokenAccountTx;\n            mintToTx = _yield$prepareTokenAc.mintToTx;\n            _context14.next = 9;\n            return Metadata.getPDA(mint.publicKey);\n\n          case 9:\n            metadataPDA = _context14.sent;\n            _context14.next = 12;\n            return MasterEdition.getPDA(mint.publicKey);\n\n          case 12:\n            editionPDA = _context14.sent;\n            _context14.next = 15;\n            return lookup(uri);\n\n          case 15:\n            _yield$lookup = _context14.sent;\n            name = _yield$lookup.name;\n            symbol = _yield$lookup.symbol;\n            seller_fee_basis_points = _yield$lookup.seller_fee_basis_points;\n            creators = _yield$lookup.properties.creators;\n            creatorsData = creators.reduce(function (memo, _ref12) {\n              var address = _ref12.address,\n                  share = _ref12.share;\n              var verified = address === wallet.publicKey.toString();\n              var creator = new Creator({\n                address: address,\n                share: share,\n                verified: verified\n              });\n              memo = [].concat(_toConsumableArray(memo), [creator]);\n              return memo;\n            }, []);\n            metadataData = new MetadataDataData({\n              name: name,\n              symbol: symbol,\n              uri: uri,\n              sellerFeeBasisPoints: seller_fee_basis_points,\n              creators: creatorsData\n            });\n            createMetadataTx = new CreateMetadata({\n              feePayer: wallet.publicKey\n            }, {\n              metadata: metadataPDA,\n              metadataData: metadataData,\n              updateAuthority: wallet.publicKey,\n              mint: mint.publicKey,\n              mintAuthority: wallet.publicKey\n            });\n            masterEditionTx = new CreateMasterEdition({\n              feePayer: wallet.publicKey\n            }, {\n              edition: editionPDA,\n              metadata: metadataPDA,\n              updateAuthority: wallet.publicKey,\n              mint: mint.publicKey,\n              mintAuthority: wallet.publicKey,\n              maxSupply: maxSupply || maxSupply === 0 ? new BN(maxSupply) : null\n            });\n            _context14.next = 26;\n            return sendTransaction({\n              connection: connection,\n              signers: [mint],\n              txs: [createMintTx, createMetadataTx, createAssociatedTokenAccountTx, mintToTx, masterEditionTx],\n              wallet: wallet\n            });\n\n          case 26:\n            txId = _context14.sent;\n            return _context14.abrupt(\"return\", {\n              txId: txId,\n              mint: mint.publicKey,\n              metadata: metadataPDA,\n              edition: editionPDA\n            });\n\n          case 28:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, _callee14);\n  }));\n};\n\nvar mintEditionFromMaster = function mintEditionFromMaster() {\n  var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      connection = _ref13.connection,\n      wallet = _ref13.wallet,\n      masterEditionMint = _ref13.masterEditionMint,\n      updateAuthority = _ref13.updateAuthority;\n\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n    var masterPDA, masterMetaPDA, masterInfo, masterData, editionValue, _yield$prepareTokenAc2, mint, createMintTx, createAssociatedTokenAccountTx, mintToTx, tokenAccount, metadataPDA, editionMarker, editionPDA, newEditionFromMasterTx, txId;\n\n    return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            _context15.next = 2;\n            return MasterEdition.getPDA(masterEditionMint);\n\n          case 2:\n            masterPDA = _context15.sent;\n            _context15.next = 5;\n            return Metadata.getPDA(masterEditionMint);\n\n          case 5:\n            masterMetaPDA = _context15.sent;\n            _context15.next = 8;\n            return Account.getInfo(connection, masterPDA);\n\n          case 8:\n            masterInfo = _context15.sent;\n            masterData = new MasterEdition(masterPDA, masterInfo).data;\n            editionValue = masterData.supply.add(new BN(1));\n            _context15.next = 13;\n            return prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\n\n          case 13:\n            _yield$prepareTokenAc2 = _context15.sent;\n            mint = _yield$prepareTokenAc2.mint;\n            createMintTx = _yield$prepareTokenAc2.createMintTx;\n            createAssociatedTokenAccountTx = _yield$prepareTokenAc2.createAssociatedTokenAccountTx;\n            mintToTx = _yield$prepareTokenAc2.mintToTx;\n            _context15.next = 20;\n            return Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, masterEditionMint, wallet.publicKey);\n\n          case 20:\n            tokenAccount = _context15.sent;\n            _context15.next = 23;\n            return Metadata.getPDA(mint.publicKey);\n\n          case 23:\n            metadataPDA = _context15.sent;\n            _context15.next = 26;\n            return EditionMarker.getPDA(masterEditionMint, editionValue);\n\n          case 26:\n            editionMarker = _context15.sent;\n            _context15.next = 29;\n            return Edition.getPDA(mint.publicKey);\n\n          case 29:\n            editionPDA = _context15.sent;\n            newEditionFromMasterTx = new MintNewEditionFromMasterEditionViaToken({\n              feePayer: wallet.publicKey\n            }, {\n              edition: editionPDA,\n              metadata: metadataPDA,\n              updateAuthority: updateAuthority !== null && updateAuthority !== void 0 ? updateAuthority : wallet.publicKey,\n              mint: mint.publicKey,\n              mintAuthority: wallet.publicKey,\n              masterEdition: masterPDA,\n              masterMetadata: masterMetaPDA,\n              editionMarker: editionMarker,\n              tokenOwner: wallet.publicKey,\n              tokenAccount: tokenAccount,\n              editionValue: editionValue\n            });\n            _context15.next = 33;\n            return sendTransaction({\n              connection: connection,\n              signers: [mint],\n              txs: [createMintTx, createAssociatedTokenAccountTx, mintToTx, newEditionFromMasterTx],\n              wallet: wallet\n            });\n\n          case 33:\n            txId = _context15.sent;\n            return _context15.abrupt(\"return\", {\n              txId: txId,\n              mint: mint.publicKey,\n              metadata: metadataPDA,\n              edition: editionPDA\n            });\n\n          case 35:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, _callee15);\n  }));\n};\n\nvar createMetadata = function createMetadata() {\n  var _ref14 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      connection = _ref14.connection,\n      wallet = _ref14.wallet,\n      editionMint = _ref14.editionMint,\n      metadataData = _ref14.metadataData,\n      updateAuthority = _ref14.updateAuthority;\n\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n    var metadata, createMetadataTx;\n    return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n      while (1) {\n        switch (_context16.prev = _context16.next) {\n          case 0:\n            _context16.next = 2;\n            return Metadata.getPDA(editionMint);\n\n          case 2:\n            metadata = _context16.sent;\n            createMetadataTx = new CreateMetadata({\n              feePayer: wallet.publicKey\n            }, {\n              metadata: metadata,\n              metadataData: metadataData,\n              updateAuthority: updateAuthority !== null && updateAuthority !== void 0 ? updateAuthority : wallet.publicKey,\n              mint: editionMint,\n              mintAuthority: wallet.publicKey\n            });\n            return _context16.abrupt(\"return\", sendTransaction({\n              connection: connection,\n              signers: [],\n              txs: [createMetadataTx],\n              wallet: wallet\n            }));\n\n          case 5:\n          case \"end\":\n            return _context16.stop();\n        }\n      }\n    }, _callee16);\n  }));\n};\n\nvar createMasterEdition = function createMasterEdition() {\n  var _ref15 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      connection = _ref15.connection,\n      wallet = _ref15.wallet,\n      editionMint = _ref15.editionMint,\n      updateAuthority = _ref15.updateAuthority,\n      maxSupply = _ref15.maxSupply;\n\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {\n    var metadata, edition, createMetadataTx;\n    return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n      while (1) {\n        switch (_context17.prev = _context17.next) {\n          case 0:\n            _context17.next = 2;\n            return Metadata.getPDA(editionMint);\n\n          case 2:\n            metadata = _context17.sent;\n            _context17.next = 5;\n            return MasterEdition.getPDA(editionMint);\n\n          case 5:\n            edition = _context17.sent;\n            createMetadataTx = new CreateMasterEdition({\n              feePayer: wallet.publicKey\n            }, {\n              edition: edition,\n              metadata: metadata,\n              updateAuthority: updateAuthority !== null && updateAuthority !== void 0 ? updateAuthority : wallet.publicKey,\n              mint: editionMint,\n              mintAuthority: wallet.publicKey,\n              maxSupply: maxSupply\n            });\n            return _context17.abrupt(\"return\", sendTransaction({\n              connection: connection,\n              signers: [],\n              txs: [createMetadataTx],\n              wallet: wallet\n            }));\n\n          case 8:\n          case \"end\":\n            return _context17.stop();\n        }\n      }\n    }, _callee17);\n  }));\n};\n\nvar signMetadata = function signMetadata() {\n  var _ref16 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      connection = _ref16.connection,\n      wallet = _ref16.wallet,\n      editionMint = _ref16.editionMint,\n      signer = _ref16.signer;\n\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {\n    var metadata, signTx;\n    return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n      while (1) {\n        switch (_context18.prev = _context18.next) {\n          case 0:\n            _context18.next = 2;\n            return Metadata.getPDA(editionMint);\n\n          case 2:\n            metadata = _context18.sent;\n            signTx = new SignMetadata({\n              feePayer: wallet.publicKey\n            }, {\n              metadata: metadata,\n              creator: signer ? signer.publicKey : wallet.publicKey\n            });\n            _context18.next = 6;\n            return sendTransaction({\n              connection: connection,\n              signers: signer ? [signer] : [],\n              txs: [signTx],\n              wallet: wallet\n            });\n\n          case 6:\n            return _context18.abrupt(\"return\", _context18.sent);\n\n          case 7:\n          case \"end\":\n            return _context18.stop();\n        }\n      }\n    }, _callee18);\n  }));\n};\n\nvar updateMetadata = function updateMetadata() {\n  var _ref17 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      connection = _ref17.connection,\n      wallet = _ref17.wallet,\n      editionMint = _ref17.editionMint,\n      newMetadataData = _ref17.newMetadataData,\n      newUpdateAuthority = _ref17.newUpdateAuthority,\n      primarySaleHappened = _ref17.primarySaleHappened;\n\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee19() {\n    var metadata, updateTx;\n    return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n      while (1) {\n        switch (_context19.prev = _context19.next) {\n          case 0:\n            _context19.next = 2;\n            return Metadata.getPDA(editionMint);\n\n          case 2:\n            metadata = _context19.sent;\n            updateTx = new UpdateMetadata({\n              feePayer: wallet.publicKey\n            }, {\n              metadata: metadata,\n              updateAuthority: wallet.publicKey,\n              metadataData: newMetadataData,\n              newUpdateAuthority: newUpdateAuthority,\n              primarySaleHappened: primarySaleHappened\n            });\n            return _context19.abrupt(\"return\", sendTransaction({\n              connection: connection,\n              signers: [],\n              txs: [updateTx],\n              wallet: wallet\n            }));\n\n          case 5:\n          case \"end\":\n            return _context19.stop();\n        }\n      }\n    }, _callee19);\n  }));\n};\n\nvar cancelBid = function cancelBid(_ref18) {\n  var connection = _ref18.connection,\n      wallet = _ref18.wallet,\n      auction = _ref18.auction,\n      bidderPotToken = _ref18.bidderPotToken,\n      destAccount = _ref18.destAccount;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee20() {\n    var bidder, auctionManager, manager, _yield$manager$getAuc, tokenMint, auctionTokenMint, vault, auctionExtended, bidderPot, bidderMeta, accountRentExempt, txBatch, txId;\n\n    return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n      while (1) {\n        switch (_context20.prev = _context20.next) {\n          case 0:\n            bidder = wallet.publicKey;\n            _context20.next = 3;\n            return AuctionManager.getPDA(auction);\n\n          case 3:\n            auctionManager = _context20.sent;\n            _context20.next = 6;\n            return AuctionManager.load(connection, auctionManager);\n\n          case 6:\n            manager = _context20.sent;\n            _context20.next = 9;\n            return manager.getAuction(connection);\n\n          case 9:\n            _yield$manager$getAuc = _context20.sent;\n            tokenMint = _yield$manager$getAuc.data.tokenMint;\n            auctionTokenMint = new PublicKey(tokenMint);\n            vault = new PublicKey(manager.data.vault);\n            _context20.next = 15;\n            return AuctionExtended.getPDA(vault);\n\n          case 15:\n            auctionExtended = _context20.sent;\n            _context20.next = 18;\n            return BidderPot.getPDA(auction, bidder);\n\n          case 18:\n            bidderPot = _context20.sent;\n            _context20.next = 21;\n            return BidderMetadata.getPDA(auction, bidder);\n\n          case 21:\n            bidderMeta = _context20.sent;\n            _context20.next = 24;\n            return connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n\n          case 24:\n            accountRentExempt = _context20.sent;\n            _context20.next = 27;\n            return getCancelBidTransactions({\n              destAccount: destAccount,\n              bidder: bidder,\n              accountRentExempt: accountRentExempt,\n              bidderPot: bidderPot,\n              bidderPotToken: bidderPotToken,\n              bidderMeta: bidderMeta,\n              auction: auction,\n              auctionExtended: auctionExtended,\n              auctionTokenMint: auctionTokenMint,\n              vault: vault\n            });\n\n          case 27:\n            txBatch = _context20.sent;\n            _context20.next = 30;\n            return sendTransaction({\n              connection: connection,\n              wallet: wallet,\n              txs: txBatch.toTransactions(),\n              signers: txBatch.signers\n            });\n\n          case 30:\n            txId = _context20.sent;\n            return _context20.abrupt(\"return\", {\n              txId: txId\n            });\n\n          case 32:\n          case \"end\":\n            return _context20.stop();\n        }\n      }\n    }, _callee20);\n  }));\n};\n\nvar getCancelBidTransactions = function getCancelBidTransactions(_ref19) {\n  var destAccount = _ref19.destAccount,\n      bidder = _ref19.bidder,\n      accountRentExempt = _ref19.accountRentExempt,\n      bidderPot = _ref19.bidderPot,\n      bidderPotToken = _ref19.bidderPotToken,\n      bidderMeta = _ref19.bidderMeta,\n      auction = _ref19.auction,\n      auctionExtended = _ref19.auctionExtended,\n      auctionTokenMint = _ref19.auctionTokenMint,\n      vault = _ref19.vault;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee21() {\n    var txBatch, account, createTokenAccountTransaction, closeTokenAccountInstruction, cancelBidTransaction;\n    return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n      while (1) {\n        switch (_context21.prev = _context21.next) {\n          case 0:\n            txBatch = new TransactionsBatch({\n              transactions: []\n            });\n\n            if (!destAccount) {\n              account = Keypair.generate();\n              createTokenAccountTransaction = new CreateTokenAccount({\n                feePayer: bidder\n              }, {\n                newAccountPubkey: account.publicKey,\n                lamports: accountRentExempt,\n                mint: NATIVE_MINT\n              });\n              closeTokenAccountInstruction = new Transaction().add(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, account.publicKey, bidder, bidder, []));\n              txBatch.addTransaction(createTokenAccountTransaction);\n              txBatch.addAfterTransaction(closeTokenAccountInstruction);\n              txBatch.addSigner(account);\n              destAccount = account.publicKey;\n            }\n\n            cancelBidTransaction = new CancelBid({\n              feePayer: bidder\n            }, {\n              bidder: bidder,\n              bidderToken: destAccount,\n              bidderPot: bidderPot,\n              bidderPotToken: bidderPotToken,\n              bidderMeta: bidderMeta,\n              auction: auction,\n              auctionExtended: auctionExtended,\n              tokenMint: auctionTokenMint,\n              resource: vault\n            });\n            txBatch.addTransaction(cancelBidTransaction);\n            return _context21.abrupt(\"return\", txBatch);\n\n          case 5:\n          case \"end\":\n            return _context21.stop();\n        }\n      }\n    }, _callee21);\n  }));\n};\n\nvar placeBid = function placeBid(_ref20) {\n  var connection = _ref20.connection,\n      wallet = _ref20.wallet,\n      amount = _ref20.amount,\n      auction = _ref20.auction,\n      bidderPotToken = _ref20.bidderPotToken;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee22() {\n    var bidder, accountRentExempt, auctionManager, manager, _yield$manager$getAuc2, tokenMint, auctionTokenMint, vault, auctionExtended, bidderPot, bidderMeta, txBatch, account, createBidderPotTransaction, _yield$createWrappedA, payingAccount, createTokenAccountTx, closeTokenAccountTx, _createApproveTxs2, transferAuthority, createApproveTx, createRevokeTx, placeBidTransaction, txId;\n\n    return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n      while (1) {\n        switch (_context22.prev = _context22.next) {\n          case 0:\n            bidder = wallet.publicKey;\n            _context22.next = 3;\n            return connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n\n          case 3:\n            accountRentExempt = _context22.sent;\n            _context22.next = 6;\n            return AuctionManager.getPDA(auction);\n\n          case 6:\n            auctionManager = _context22.sent;\n            _context22.next = 9;\n            return AuctionManager.load(connection, auctionManager);\n\n          case 9:\n            manager = _context22.sent;\n            _context22.next = 12;\n            return manager.getAuction(connection);\n\n          case 12:\n            _yield$manager$getAuc2 = _context22.sent;\n            tokenMint = _yield$manager$getAuc2.data.tokenMint;\n            auctionTokenMint = new PublicKey(tokenMint);\n            vault = new PublicKey(manager.data.vault);\n            _context22.next = 18;\n            return AuctionExtended.getPDA(vault);\n\n          case 18:\n            auctionExtended = _context22.sent;\n            _context22.next = 21;\n            return BidderPot.getPDA(auction, bidder);\n\n          case 21:\n            bidderPot = _context22.sent;\n            _context22.next = 24;\n            return BidderMetadata.getPDA(auction, bidder);\n\n          case 24:\n            bidderMeta = _context22.sent;\n            txBatch = new TransactionsBatch({\n              transactions: []\n            });\n\n            if (!bidderPotToken) {\n              _context22.next = 32;\n              break;\n            }\n\n            _context22.next = 29;\n            return getCancelBidTransactions({\n              destAccount: null,\n              bidder: bidder,\n              accountRentExempt: accountRentExempt,\n              bidderPot: bidderPot,\n              bidderPotToken: bidderPotToken,\n              bidderMeta: bidderMeta,\n              auction: auction,\n              auctionExtended: auctionExtended,\n              auctionTokenMint: auctionTokenMint,\n              vault: vault\n            });\n\n          case 29:\n            txBatch = _context22.sent;\n            _context22.next = 37;\n            break;\n\n          case 32:\n            account = Keypair.generate();\n            createBidderPotTransaction = new CreateTokenAccount({\n              feePayer: bidder\n            }, {\n              newAccountPubkey: account.publicKey,\n              lamports: accountRentExempt,\n              mint: auctionTokenMint,\n              owner: auction\n            });\n            txBatch.addSigner(account);\n            txBatch.addTransaction(createBidderPotTransaction);\n            bidderPotToken = account.publicKey;\n\n          case 37:\n            _context22.next = 39;\n            return createWrappedAccountTxs(connection, bidder, amount.toNumber() + accountRentExempt * 2);\n\n          case 39:\n            _yield$createWrappedA = _context22.sent;\n            payingAccount = _yield$createWrappedA.account;\n            createTokenAccountTx = _yield$createWrappedA.createTokenAccountTx;\n            closeTokenAccountTx = _yield$createWrappedA.closeTokenAccountTx;\n            txBatch.addTransaction(createTokenAccountTx);\n            txBatch.addAfterTransaction(closeTokenAccountTx);\n            txBatch.addSigner(payingAccount);\n            _createApproveTxs2 = createApproveTxs({\n              account: payingAccount.publicKey,\n              owner: bidder,\n              amount: amount.toNumber()\n            }), transferAuthority = _createApproveTxs2.authority, createApproveTx = _createApproveTxs2.createApproveTx, createRevokeTx = _createApproveTxs2.createRevokeTx;\n            txBatch.addTransaction(createApproveTx);\n            txBatch.addAfterTransaction(createRevokeTx);\n            txBatch.addSigner(transferAuthority);\n            placeBidTransaction = new PlaceBid({\n              feePayer: bidder\n            }, {\n              bidder: bidder,\n              bidderToken: payingAccount.publicKey,\n              bidderPot: bidderPot,\n              bidderPotToken: bidderPotToken,\n              bidderMeta: bidderMeta,\n              auction: auction,\n              auctionExtended: auctionExtended,\n              tokenMint: auctionTokenMint,\n              transferAuthority: transferAuthority.publicKey,\n              amount: amount,\n              resource: vault\n            });\n            txBatch.addTransaction(placeBidTransaction);\n            _context22.next = 54;\n            return sendTransaction({\n              connection: connection,\n              wallet: wallet,\n              txs: txBatch.toTransactions(),\n              signers: txBatch.signers\n            });\n\n          case 54:\n            txId = _context22.sent;\n            return _context22.abrupt(\"return\", {\n              txId: txId,\n              bidderPotToken: bidderPotToken,\n              bidderMeta: bidderMeta\n            });\n\n          case 56:\n          case \"end\":\n            return _context22.stop();\n        }\n      }\n    }, _callee22);\n  }));\n};\n\nvar redeemFullRightsTransferBid = function redeemFullRightsTransferBid(_ref21) {\n  var connection = _ref21.connection,\n      wallet = _ref21.wallet,\n      store = _ref21.store,\n      auction = _ref21.auction;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee23() {\n    var bidder, accountRentExempt, auctionManager, manager, vault, fractionMint, auctionExtended, _yield$vault$getSafet, _yield$vault$getSafet2, safetyDepositBox, tokenMint, safetyDepositTokenStore, bidderMeta, bidRedemption, safetyDepositConfig, transferAuthority, metadata, txBatch, txId;\n\n    return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n      while (1) {\n        switch (_context23.prev = _context23.next) {\n          case 0:\n            bidder = wallet.publicKey;\n            _context23.next = 3;\n            return connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n\n          case 3:\n            accountRentExempt = _context23.sent;\n            _context23.next = 6;\n            return AuctionManager.getPDA(auction);\n\n          case 6:\n            auctionManager = _context23.sent;\n            _context23.next = 9;\n            return AuctionManager.load(connection, auctionManager);\n\n          case 9:\n            manager = _context23.sent;\n            _context23.next = 12;\n            return Vault.load(connection, manager.data.vault);\n\n          case 12:\n            vault = _context23.sent;\n            fractionMint = new PublicKey(vault.data.fractionMint);\n            _context23.next = 16;\n            return AuctionExtended.getPDA(vault.pubkey);\n\n          case 16:\n            auctionExtended = _context23.sent;\n            _context23.next = 19;\n            return vault.getSafetyDepositBoxes(connection);\n\n          case 19:\n            _yield$vault$getSafet = _context23.sent;\n            _yield$vault$getSafet2 = _slicedToArray(_yield$vault$getSafet, 1);\n            safetyDepositBox = _yield$vault$getSafet2[0];\n            tokenMint = new PublicKey(safetyDepositBox.data.tokenMint);\n            safetyDepositTokenStore = new PublicKey(safetyDepositBox.data.store);\n            _context23.next = 26;\n            return BidderMetadata.getPDA(auction, bidder);\n\n          case 26:\n            bidderMeta = _context23.sent;\n            _context23.next = 29;\n            return getBidRedemptionPDA(auction, bidderMeta);\n\n          case 29:\n            bidRedemption = _context23.sent;\n            _context23.next = 32;\n            return SafetyDepositConfig.getPDA(auctionManager, safetyDepositBox.pubkey);\n\n          case 32:\n            safetyDepositConfig = _context23.sent;\n            _context23.next = 35;\n            return Vault.getPDA(vault.pubkey);\n\n          case 35:\n            transferAuthority = _context23.sent;\n            _context23.next = 38;\n            return Metadata.getPDA(tokenMint);\n\n          case 38:\n            metadata = _context23.sent;\n            _context23.next = 41;\n            return getRedeemFRTBidTransactions({\n              accountRentExempt: accountRentExempt,\n              tokenMint: tokenMint,\n              bidder: bidder,\n              bidderMeta: bidderMeta,\n              store: store,\n              vault: vault.pubkey,\n              auction: auction,\n              auctionExtended: auctionExtended,\n              auctionManager: auctionManager,\n              fractionMint: fractionMint,\n              safetyDepositTokenStore: safetyDepositTokenStore,\n              safetyDeposit: safetyDepositBox.pubkey,\n              bidRedemption: bidRedemption,\n              safetyDepositConfig: safetyDepositConfig,\n              transferAuthority: transferAuthority,\n              metadata: metadata\n            });\n\n          case 41:\n            txBatch = _context23.sent;\n            _context23.next = 44;\n            return sendTransaction({\n              connection: connection,\n              wallet: wallet,\n              txs: txBatch.toTransactions(),\n              signers: txBatch.signers\n            });\n\n          case 44:\n            txId = _context23.sent;\n            return _context23.abrupt(\"return\", {\n              txId: txId\n            });\n\n          case 46:\n          case \"end\":\n            return _context23.stop();\n        }\n      }\n    }, _callee23);\n  }));\n};\n\nvar getRedeemFRTBidTransactions = function getRedeemFRTBidTransactions(_ref22) {\n  var accountRentExempt = _ref22.accountRentExempt,\n      bidder = _ref22.bidder,\n      tokenMint = _ref22.tokenMint,\n      store = _ref22.store,\n      vault = _ref22.vault,\n      auction = _ref22.auction,\n      auctionManager = _ref22.auctionManager,\n      auctionExtended = _ref22.auctionExtended,\n      bidRedemption = _ref22.bidRedemption,\n      bidMetadata = _ref22.bidderMeta,\n      safetyDepositTokenStore = _ref22.safetyDepositTokenStore,\n      safetyDeposit = _ref22.safetyDeposit,\n      fractionMint = _ref22.fractionMint,\n      safetyDepositConfig = _ref22.safetyDepositConfig,\n      transferAuthority = _ref22.transferAuthority,\n      metadata = _ref22.metadata;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee24() {\n    var txBatch, account, createDestinationTransaction, redeemBidTransaction, updatePrimarySaleHappenedViaTokenTransaction;\n    return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n      while (1) {\n        switch (_context24.prev = _context24.next) {\n          case 0:\n            txBatch = new TransactionsBatch({\n              transactions: []\n            });\n            account = Keypair.generate();\n            createDestinationTransaction = new CreateTokenAccount({\n              feePayer: bidder\n            }, {\n              newAccountPubkey: account.publicKey,\n              lamports: accountRentExempt,\n              mint: tokenMint\n            });\n            txBatch.addSigner(account);\n            txBatch.addTransaction(createDestinationTransaction);\n            redeemBidTransaction = new RedeemFullRightsTransferBid({\n              feePayer: bidder\n            }, {\n              store: store,\n              vault: vault,\n              auction: auction,\n              auctionManager: auctionManager,\n              bidRedemption: bidRedemption,\n              bidMetadata: bidMetadata,\n              safetyDepositTokenStore: safetyDepositTokenStore,\n              destination: account.publicKey,\n              safetyDeposit: safetyDeposit,\n              fractionMint: fractionMint,\n              bidder: bidder,\n              safetyDepositConfig: safetyDepositConfig,\n              auctionExtended: auctionExtended,\n              transferAuthority: transferAuthority,\n              newAuthority: bidder,\n              masterMetadata: metadata\n            });\n            txBatch.addTransaction(redeemBidTransaction);\n            updatePrimarySaleHappenedViaTokenTransaction = new UpdatePrimarySaleHappenedViaToken({\n              feePayer: bidder\n            }, {\n              metadata: metadata,\n              owner: bidder,\n              tokenAccount: account.publicKey\n            });\n            txBatch.addTransaction(updatePrimarySaleHappenedViaTokenTransaction);\n            return _context24.abrupt(\"return\", txBatch);\n\n          case 10:\n          case \"end\":\n            return _context24.stop();\n        }\n      }\n    }, _callee24);\n  }));\n};\n\nvar getBidRedemptionPDA = function getBidRedemptionPDA(auction, bidderMeta) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee25() {\n    return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n      while (1) {\n        switch (_context25.prev = _context25.next) {\n          case 0:\n            _context25.next = 2;\n            return PublicKey.findProgramAddress([Buffer.from(MetaplexProgram.PREFIX), auction.toBuffer(), bidderMeta.toBuffer()], MetaplexProgram.PUBKEY);\n\n          case 2:\n            return _context25.abrupt(\"return\", _context25.sent[0]);\n\n          case 3:\n          case \"end\":\n            return _context25.stop();\n        }\n      }\n    }, _callee25);\n  }));\n};\n\nvar redeemPrintingV2Bid = function redeemPrintingV2Bid(_ref23) {\n  var connection = _ref23.connection,\n      wallet = _ref23.wallet,\n      store = _ref23.store,\n      auction = _ref23.auction;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee26() {\n    var bidder, _yield$Auction$load, bidState, auctionManagerPDA, manager, vault, auctionExtendedPDA, _yield$vault$getSafet3, _yield$vault$getSafet4, safetyDepositBox, originalMint, safetyDepositTokenStore, bidderMetaPDA, bidRedemptionPDA, safetyDepositConfigPDA, _yield$prepareTokenAc3, mint, createMintTx, createAssociatedTokenAccountTx, mintToTx, recipient, newMint, newMetadataPDA, newEditionPDA, metadataPDA, masterEditionPDA, masterEdition, prizeTrackingTicketPDA, prizeTrackingTicket, winIndex, editionOffset, editionBase, desiredEdition, editionMarkerPDA, editionMarker, isEditionTaken, txBatch, txId;\n\n    return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n      while (1) {\n        switch (_context26.prev = _context26.next) {\n          case 0:\n            bidder = wallet.publicKey;\n            _context26.next = 3;\n            return Auction.load(connection, auction);\n\n          case 3:\n            _yield$Auction$load = _context26.sent;\n            bidState = _yield$Auction$load.data.bidState;\n            _context26.next = 7;\n            return AuctionManager.getPDA(auction);\n\n          case 7:\n            auctionManagerPDA = _context26.sent;\n            _context26.next = 10;\n            return AuctionManager.load(connection, auctionManagerPDA);\n\n          case 10:\n            manager = _context26.sent;\n            _context26.next = 13;\n            return Vault.load(connection, manager.data.vault);\n\n          case 13:\n            vault = _context26.sent;\n            _context26.next = 16;\n            return AuctionExtended.getPDA(vault.pubkey);\n\n          case 16:\n            auctionExtendedPDA = _context26.sent;\n            _context26.next = 19;\n            return vault.getSafetyDepositBoxes(connection);\n\n          case 19:\n            _yield$vault$getSafet3 = _context26.sent;\n            _yield$vault$getSafet4 = _slicedToArray(_yield$vault$getSafet3, 1);\n            safetyDepositBox = _yield$vault$getSafet4[0];\n            originalMint = new PublicKey(safetyDepositBox.data.tokenMint);\n            safetyDepositTokenStore = new PublicKey(safetyDepositBox.data.store);\n            _context26.next = 26;\n            return BidderMetadata.getPDA(auction, bidder);\n\n          case 26:\n            bidderMetaPDA = _context26.sent;\n            _context26.next = 29;\n            return getBidRedemptionPDA(auction, bidderMetaPDA);\n\n          case 29:\n            bidRedemptionPDA = _context26.sent;\n            _context26.next = 32;\n            return SafetyDepositConfig.getPDA(auctionManagerPDA, safetyDepositBox.pubkey);\n\n          case 32:\n            safetyDepositConfigPDA = _context26.sent;\n            _context26.next = 35;\n            return prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\n\n          case 35:\n            _yield$prepareTokenAc3 = _context26.sent;\n            mint = _yield$prepareTokenAc3.mint;\n            createMintTx = _yield$prepareTokenAc3.createMintTx;\n            createAssociatedTokenAccountTx = _yield$prepareTokenAc3.createAssociatedTokenAccountTx;\n            mintToTx = _yield$prepareTokenAc3.mintToTx;\n            recipient = _yield$prepareTokenAc3.recipient;\n            newMint = mint.publicKey;\n            _context26.next = 44;\n            return Metadata.getPDA(newMint);\n\n          case 44:\n            newMetadataPDA = _context26.sent;\n            _context26.next = 47;\n            return Edition.getPDA(newMint);\n\n          case 47:\n            newEditionPDA = _context26.sent;\n            _context26.next = 50;\n            return Metadata.getPDA(originalMint);\n\n          case 50:\n            metadataPDA = _context26.sent;\n            _context26.next = 53;\n            return MasterEdition.getPDA(originalMint);\n\n          case 53:\n            masterEditionPDA = _context26.sent;\n            _context26.next = 56;\n            return MasterEdition.load(connection, masterEditionPDA);\n\n          case 56:\n            masterEdition = _context26.sent;\n            _context26.next = 59;\n            return PrizeTrackingTicket.getPDA(auctionManagerPDA, originalMint);\n\n          case 59:\n            prizeTrackingTicketPDA = _context26.sent;\n            _context26.prev = 60;\n            _context26.next = 63;\n            return PrizeTrackingTicket.load(connection, prizeTrackingTicketPDA);\n\n          case 63:\n            prizeTrackingTicket = _context26.sent;\n            _context26.next = 69;\n            break;\n\n          case 66:\n            _context26.prev = 66;\n            _context26.t0 = _context26[\"catch\"](60);\n            prizeTrackingTicket = null;\n\n          case 69:\n            winIndex = bidState.getWinnerIndex(bidder.toBase58()) || 0;\n            editionOffset = getEditionOffset(winIndex);\n            editionBase = (prizeTrackingTicket === null || prizeTrackingTicket === void 0 ? void 0 : prizeTrackingTicket.data.supplySnapshot) || masterEdition.data.supply;\n            desiredEdition = editionBase.add(editionOffset);\n            _context26.next = 75;\n            return EditionMarker.getPDA(originalMint, desiredEdition);\n\n          case 75:\n            editionMarkerPDA = _context26.sent;\n            _context26.prev = 76;\n            _context26.next = 79;\n            return EditionMarker.load(connection, editionMarkerPDA);\n\n          case 79:\n            editionMarker = _context26.sent;\n            isEditionTaken = editionMarker.data.editionTaken(desiredEdition.toNumber());\n\n            if (!isEditionTaken) {\n              _context26.next = 83;\n              break;\n            }\n\n            throw new Error('The edition is already taken');\n\n          case 83:\n            _context26.next = 87;\n            break;\n\n          case 85:\n            _context26.prev = 85;\n            _context26.t1 = _context26[\"catch\"](76);\n\n          case 87:\n            _context26.next = 89;\n            return getRedeemPrintingV2BidTransactions({\n              bidder: bidder,\n              bidderMeta: bidderMetaPDA,\n              store: store,\n              vault: vault.pubkey,\n              destination: recipient,\n              auction: auction,\n              auctionExtended: auctionExtendedPDA,\n              auctionManager: auctionManagerPDA,\n              safetyDepositTokenStore: safetyDepositTokenStore,\n              safetyDeposit: safetyDepositBox.pubkey,\n              bidRedemption: bidRedemptionPDA,\n              safetyDepositConfig: safetyDepositConfigPDA,\n              metadata: metadataPDA,\n              newMint: newMint,\n              newMetadata: newMetadataPDA,\n              newEdition: newEditionPDA,\n              masterEdition: masterEditionPDA,\n              editionMarker: editionMarkerPDA,\n              prizeTrackingTicket: prizeTrackingTicketPDA,\n              editionOffset: editionOffset,\n              winIndex: new BN(winIndex)\n            });\n\n          case 89:\n            txBatch = _context26.sent;\n            txBatch.addSigner(mint);\n            txBatch.addBeforeTransaction(createMintTx);\n            txBatch.addBeforeTransaction(createAssociatedTokenAccountTx);\n            txBatch.addBeforeTransaction(mintToTx);\n            _context26.next = 96;\n            return sendTransaction({\n              connection: connection,\n              wallet: wallet,\n              txs: txBatch.toTransactions(),\n              signers: txBatch.signers\n            });\n\n          case 96:\n            txId = _context26.sent;\n            return _context26.abrupt(\"return\", {\n              txId: txId\n            });\n\n          case 98:\n          case \"end\":\n            return _context26.stop();\n        }\n      }\n    }, _callee26, null, [[60, 66], [76, 85]]);\n  }));\n};\n\nvar getRedeemPrintingV2BidTransactions = function getRedeemPrintingV2BidTransactions(_ref24) {\n  var bidder = _ref24.bidder,\n      destination = _ref24.destination,\n      store = _ref24.store,\n      vault = _ref24.vault,\n      auction = _ref24.auction,\n      auctionManager = _ref24.auctionManager,\n      auctionExtended = _ref24.auctionExtended,\n      bidRedemption = _ref24.bidRedemption,\n      bidMetadata = _ref24.bidderMeta,\n      safetyDepositTokenStore = _ref24.safetyDepositTokenStore,\n      safetyDeposit = _ref24.safetyDeposit,\n      safetyDepositConfig = _ref24.safetyDepositConfig,\n      metadata = _ref24.metadata,\n      newMint = _ref24.newMint,\n      newMetadata = _ref24.newMetadata,\n      newEdition = _ref24.newEdition,\n      masterEdition = _ref24.masterEdition,\n      editionMark = _ref24.editionMarker,\n      prizeTrackingTicket = _ref24.prizeTrackingTicket,\n      winIndex = _ref24.winIndex,\n      editionOffset = _ref24.editionOffset;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee27() {\n    var txBatch, redeemPrintingV2BidTx, updatePrimarySaleHappenedViaTokenTx;\n    return _regeneratorRuntime.wrap(function _callee27$(_context27) {\n      while (1) {\n        switch (_context27.prev = _context27.next) {\n          case 0:\n            txBatch = new TransactionsBatch({\n              transactions: []\n            });\n            redeemPrintingV2BidTx = new RedeemPrintingV2Bid({\n              feePayer: bidder\n            }, {\n              store: store,\n              vault: vault,\n              auction: auction,\n              auctionManager: auctionManager,\n              bidRedemption: bidRedemption,\n              bidMetadata: bidMetadata,\n              safetyDepositTokenStore: safetyDepositTokenStore,\n              destination: destination,\n              safetyDeposit: safetyDeposit,\n              bidder: bidder,\n              safetyDepositConfig: safetyDepositConfig,\n              auctionExtended: auctionExtended,\n              newMint: newMint,\n              newEdition: newEdition,\n              newMetadata: newMetadata,\n              metadata: metadata,\n              masterEdition: masterEdition,\n              editionMark: editionMark,\n              prizeTrackingTicket: prizeTrackingTicket,\n              winIndex: winIndex,\n              editionOffset: editionOffset\n            });\n            txBatch.addTransaction(redeemPrintingV2BidTx);\n            updatePrimarySaleHappenedViaTokenTx = new UpdatePrimarySaleHappenedViaToken({\n              feePayer: bidder\n            }, {\n              metadata: newMetadata,\n              owner: bidder,\n              tokenAccount: destination\n            });\n            txBatch.addTransaction(updatePrimarySaleHappenedViaTokenTx);\n            return _context27.abrupt(\"return\", txBatch);\n\n          case 6:\n          case \"end\":\n            return _context27.stop();\n        }\n      }\n    }, _callee27);\n  }));\n};\n\nfunction getEditionOffset(winIndex) {\n  var offset = new BN(1);\n  return offset.add(new BN(winIndex));\n}\n\nvar redeemParticipationBidV3 = function redeemParticipationBidV3(_ref25) {\n  var connection = _ref25.connection,\n      wallet = _ref25.wallet,\n      store = _ref25.store,\n      auction = _ref25.auction;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee28() {\n    var txInitBatch, txMainBatch, bidder, _yield$Auction$load2, _yield$Auction$load2$, bidState, auctionTokenMint, auctionManagerPDA, manager, vault, auctionExtendedPDA, _yield$vault$getSafet5, _yield$vault$getSafet6, safetyDepositBox, originalMint, safetyDepositTokenStore, bidderMetaPDA, bidRedemptionPDA, safetyDepositConfigPDA, _yield$SafetyDepositC, fixedPrice, acceptPaymentAccount, _yield$prepareTokenAc4, mint, createMintTx, createAssociatedTokenAccountTx, mintToTx, recipient, newMint, newMetadataPDA, newEditionPDA, metadataPDA, masterEditionPDA, masterEdition, prizeTrackingTicketPDA, winIndex, desiredEdition, editionMarkerPDA, tokenPaymentAccount, _yield$createWrappedA2, account, createTokenAccountTx, closeTokenAccountTx, _createApproveTxs3, authority, createApproveTx, createRevokeTx, redeemParticipationBidV3Tx, updatePrimarySaleHappenedViaTokenTx, initTxId, mainTxId;\n\n    return _regeneratorRuntime.wrap(function _callee28$(_context28) {\n      while (1) {\n        switch (_context28.prev = _context28.next) {\n          case 0:\n            txInitBatch = new TransactionsBatch({\n              transactions: []\n            });\n            txMainBatch = new TransactionsBatch({\n              transactions: []\n            });\n            bidder = wallet.publicKey;\n            _context28.next = 5;\n            return Auction.load(connection, auction);\n\n          case 5:\n            _yield$Auction$load2 = _context28.sent;\n            _yield$Auction$load2$ = _yield$Auction$load2.data;\n            bidState = _yield$Auction$load2$.bidState;\n            auctionTokenMint = _yield$Auction$load2$.tokenMint;\n            _context28.next = 11;\n            return AuctionManager.getPDA(auction);\n\n          case 11:\n            auctionManagerPDA = _context28.sent;\n            _context28.next = 14;\n            return AuctionManager.load(connection, auctionManagerPDA);\n\n          case 14:\n            manager = _context28.sent;\n            _context28.next = 17;\n            return Vault.load(connection, manager.data.vault);\n\n          case 17:\n            vault = _context28.sent;\n            _context28.next = 20;\n            return AuctionExtended.getPDA(vault.pubkey);\n\n          case 20:\n            auctionExtendedPDA = _context28.sent;\n            _context28.next = 23;\n            return vault.getSafetyDepositBoxes(connection);\n\n          case 23:\n            _yield$vault$getSafet5 = _context28.sent;\n            _yield$vault$getSafet6 = _slicedToArray(_yield$vault$getSafet5, 1);\n            safetyDepositBox = _yield$vault$getSafet6[0];\n            originalMint = new PublicKey(safetyDepositBox.data.tokenMint);\n            safetyDepositTokenStore = new PublicKey(safetyDepositBox.data.store);\n            _context28.next = 30;\n            return BidderMetadata.getPDA(auction, bidder);\n\n          case 30:\n            bidderMetaPDA = _context28.sent;\n            _context28.next = 33;\n            return getBidRedemptionPDA(auction, bidderMetaPDA);\n\n          case 33:\n            bidRedemptionPDA = _context28.sent;\n            _context28.next = 36;\n            return SafetyDepositConfig.getPDA(auctionManagerPDA, safetyDepositBox.pubkey);\n\n          case 36:\n            safetyDepositConfigPDA = _context28.sent;\n            _context28.next = 39;\n            return SafetyDepositConfig.load(connection, safetyDepositConfigPDA);\n\n          case 39:\n            _yield$SafetyDepositC = _context28.sent;\n            fixedPrice = _yield$SafetyDepositC.data.participationConfig.fixedPrice;\n            acceptPaymentAccount = new PublicKey(manager.data.acceptPayment);\n            _context28.next = 44;\n            return prepareTokenAccountAndMintTxs(connection, wallet.publicKey);\n\n          case 44:\n            _yield$prepareTokenAc4 = _context28.sent;\n            mint = _yield$prepareTokenAc4.mint;\n            createMintTx = _yield$prepareTokenAc4.createMintTx;\n            createAssociatedTokenAccountTx = _yield$prepareTokenAc4.createAssociatedTokenAccountTx;\n            mintToTx = _yield$prepareTokenAc4.mintToTx;\n            recipient = _yield$prepareTokenAc4.recipient;\n            txInitBatch.addSigner(mint);\n            txInitBatch.addTransaction(createMintTx);\n            txInitBatch.addTransaction(createAssociatedTokenAccountTx);\n            txInitBatch.addTransaction(mintToTx);\n            newMint = mint.publicKey;\n            _context28.next = 57;\n            return Metadata.getPDA(newMint);\n\n          case 57:\n            newMetadataPDA = _context28.sent;\n            _context28.next = 60;\n            return Edition.getPDA(newMint);\n\n          case 60:\n            newEditionPDA = _context28.sent;\n            _context28.next = 63;\n            return Metadata.getPDA(originalMint);\n\n          case 63:\n            metadataPDA = _context28.sent;\n            _context28.next = 66;\n            return MasterEdition.getPDA(originalMint);\n\n          case 66:\n            masterEditionPDA = _context28.sent;\n            _context28.next = 69;\n            return MasterEdition.load(connection, masterEditionPDA);\n\n          case 69:\n            masterEdition = _context28.sent;\n            _context28.next = 72;\n            return PrizeTrackingTicket.getPDA(auctionManagerPDA, originalMint);\n\n          case 72:\n            prizeTrackingTicketPDA = _context28.sent;\n            winIndex = bidState.getWinnerIndex(bidder.toBase58());\n            desiredEdition = masterEdition.data.supply.add(new BN(1));\n            _context28.next = 77;\n            return EditionMarker.getPDA(originalMint, desiredEdition);\n\n          case 77:\n            editionMarkerPDA = _context28.sent;\n\n            if (!(auctionTokenMint === NATIVE_MINT.toBase58())) {\n              _context28.next = 91;\n              break;\n            }\n\n            _context28.next = 81;\n            return createWrappedAccountTxs(connection, bidder, fixedPrice.toNumber());\n\n          case 81:\n            _yield$createWrappedA2 = _context28.sent;\n            account = _yield$createWrappedA2.account;\n            createTokenAccountTx = _yield$createWrappedA2.createTokenAccountTx;\n            closeTokenAccountTx = _yield$createWrappedA2.closeTokenAccountTx;\n            tokenPaymentAccount = account.publicKey;\n            txInitBatch.addTransaction(createTokenAccountTx);\n            txInitBatch.addSigner(account);\n            txMainBatch.addAfterTransaction(closeTokenAccountTx);\n            _context28.next = 94;\n            break;\n\n          case 91:\n            _context28.next = 93;\n            return Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, new PublicKey(auctionTokenMint), bidder);\n\n          case 93:\n            tokenPaymentAccount = _context28.sent;\n\n          case 94:\n            _createApproveTxs3 = createApproveTxs({\n              account: tokenPaymentAccount,\n              owner: bidder,\n              amount: fixedPrice.toNumber()\n            }), authority = _createApproveTxs3.authority, createApproveTx = _createApproveTxs3.createApproveTx, createRevokeTx = _createApproveTxs3.createRevokeTx;\n            txMainBatch.addTransaction(createApproveTx);\n            txMainBatch.addAfterTransaction(createRevokeTx);\n            txMainBatch.addSigner(authority);\n            redeemParticipationBidV3Tx = new RedeemParticipationBidV3({\n              feePayer: bidder\n            }, {\n              store: store,\n              vault: vault.pubkey,\n              auction: auction,\n              auctionManager: auctionManagerPDA,\n              bidRedemption: bidRedemptionPDA,\n              bidMetadata: bidderMetaPDA,\n              safetyDepositTokenStore: safetyDepositTokenStore,\n              destination: recipient,\n              safetyDeposit: safetyDepositBox.pubkey,\n              bidder: bidder,\n              safetyDepositConfig: safetyDepositConfigPDA,\n              auctionExtended: auctionExtendedPDA,\n              newMint: newMint,\n              newEdition: newEditionPDA,\n              newMetadata: newMetadataPDA,\n              metadata: metadataPDA,\n              masterEdition: masterEditionPDA,\n              editionMark: editionMarkerPDA,\n              prizeTrackingTicket: prizeTrackingTicketPDA,\n              winIndex: winIndex !== null ? new BN(winIndex) : null,\n              transferAuthority: authority.publicKey,\n              tokenPaymentAccount: tokenPaymentAccount,\n              acceptPaymentAccount: acceptPaymentAccount\n            });\n            txMainBatch.addTransaction(redeemParticipationBidV3Tx);\n            updatePrimarySaleHappenedViaTokenTx = new UpdatePrimarySaleHappenedViaToken({\n              feePayer: bidder\n            }, {\n              metadata: newMetadataPDA,\n              owner: bidder,\n              tokenAccount: recipient\n            });\n            txMainBatch.addTransaction(updatePrimarySaleHappenedViaTokenTx);\n            _context28.next = 104;\n            return sendTransaction({\n              connection: connection,\n              wallet: wallet,\n              txs: txInitBatch.toTransactions(),\n              signers: txInitBatch.signers\n            });\n\n          case 104:\n            initTxId = _context28.sent;\n            _context28.next = 107;\n            return connection.confirmTransaction(initTxId, 'finalized');\n\n          case 107:\n            _context28.next = 109;\n            return sendTransaction({\n              connection: connection,\n              wallet: wallet,\n              txs: txMainBatch.toTransactions(),\n              signers: txMainBatch.signers\n            });\n\n          case 109:\n            mainTxId = _context28.sent;\n            return _context28.abrupt(\"return\", {\n              txIds: [initTxId, mainTxId]\n            });\n\n          case 111:\n          case \"end\":\n            return _context28.stop();\n        }\n      }\n    }, _callee28);\n  }));\n};\n\nfunction isEligibleForParticipationPrize(winIndex) {\n  var _ref26 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      nonWinningConstraint = _ref26.nonWinningConstraint,\n      winnerConstraint = _ref26.winnerConstraint;\n\n  var noWinnerConstraints = winnerConstraint !== WinningConstraint.NoParticipationPrize;\n  var noNonWinnerConstraints = nonWinningConstraint !== NonWinningConstraint.NoParticipationPrize;\n  return winIndex === null && noNonWinnerConstraints || winIndex !== null && noWinnerConstraints;\n}\n\nvar claimBid = function claimBid(_ref27) {\n  var connection = _ref27.connection,\n      wallet = _ref27.wallet,\n      store = _ref27.store,\n      auction = _ref27.auction,\n      bidderPotToken = _ref27.bidderPotToken;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee29() {\n    var bidder, auctionManager, manager, vault, _yield$Auction$load3, tokenMint, acceptPayment, auctionExtended, auctionTokenMint, bidderPot, txBatch, txId;\n\n    return _regeneratorRuntime.wrap(function _callee29$(_context29) {\n      while (1) {\n        switch (_context29.prev = _context29.next) {\n          case 0:\n            bidder = wallet.publicKey;\n            _context29.next = 3;\n            return AuctionManager.getPDA(auction);\n\n          case 3:\n            auctionManager = _context29.sent;\n            _context29.next = 6;\n            return AuctionManager.load(connection, auctionManager);\n\n          case 6:\n            manager = _context29.sent;\n            vault = new PublicKey(manager.data.vault);\n            _context29.next = 10;\n            return Auction.load(connection, auction);\n\n          case 10:\n            _yield$Auction$load3 = _context29.sent;\n            tokenMint = _yield$Auction$load3.data.tokenMint;\n            acceptPayment = new PublicKey(manager.data.acceptPayment);\n            _context29.next = 15;\n            return AuctionExtended.getPDA(vault);\n\n          case 15:\n            auctionExtended = _context29.sent;\n            auctionTokenMint = new PublicKey(tokenMint);\n            _context29.next = 19;\n            return BidderPot.getPDA(auction, bidder);\n\n          case 19:\n            bidderPot = _context29.sent;\n            _context29.next = 22;\n            return getClaimBidTransactions({\n              auctionTokenMint: auctionTokenMint,\n              bidder: bidder,\n              store: store,\n              vault: vault,\n              auction: auction,\n              auctionExtended: auctionExtended,\n              auctionManager: auctionManager,\n              acceptPayment: acceptPayment,\n              bidderPot: bidderPot,\n              bidderPotToken: bidderPotToken\n            });\n\n          case 22:\n            txBatch = _context29.sent;\n            _context29.next = 25;\n            return sendTransaction({\n              connection: connection,\n              wallet: wallet,\n              txs: txBatch.toTransactions(),\n              signers: txBatch.signers\n            });\n\n          case 25:\n            txId = _context29.sent;\n            return _context29.abrupt(\"return\", {\n              txId: txId\n            });\n\n          case 27:\n          case \"end\":\n            return _context29.stop();\n        }\n      }\n    }, _callee29);\n  }));\n};\n\nvar getClaimBidTransactions = function getClaimBidTransactions(_ref28) {\n  var bidder = _ref28.bidder,\n      auctionTokenMint = _ref28.auctionTokenMint,\n      store = _ref28.store,\n      vault = _ref28.vault,\n      auction = _ref28.auction,\n      auctionManager = _ref28.auctionManager,\n      auctionExtended = _ref28.auctionExtended,\n      acceptPayment = _ref28.acceptPayment,\n      bidderPot = _ref28.bidderPot,\n      bidderPotToken = _ref28.bidderPotToken;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee30() {\n    var txBatch, claimBidTransaction;\n    return _regeneratorRuntime.wrap(function _callee30$(_context30) {\n      while (1) {\n        switch (_context30.prev = _context30.next) {\n          case 0:\n            txBatch = new TransactionsBatch({\n              transactions: []\n            });\n            claimBidTransaction = new ClaimBid({\n              feePayer: bidder\n            }, {\n              store: store,\n              vault: vault,\n              auction: auction,\n              auctionExtended: auctionExtended,\n              auctionManager: auctionManager,\n              bidder: bidder,\n              tokenMint: auctionTokenMint,\n              acceptPayment: acceptPayment,\n              bidderPot: bidderPot,\n              bidderPotToken: bidderPotToken\n            });\n            txBatch.addTransaction(claimBidTransaction);\n            return _context30.abrupt(\"return\", txBatch);\n\n          case 4:\n          case \"end\":\n            return _context30.stop();\n        }\n      }\n    }, _callee30);\n  }));\n};\n\nvar instantSale = function instantSale(_ref29) {\n  var connection = _ref29.connection,\n      wallet = _ref29.wallet,\n      store = _ref29.store,\n      auction = _ref29.auction;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee31() {\n    var txIds, auctionManagerPDA, manager, vault, auctionExtendedPDA, _yield$AuctionExtende, instantSalePrice, _yield$vault$getSafet7, _yield$vault$getSafet8, safetyDepositBox, safetyDepositConfigPDA, _yield$SafetyDepositC2, _yield$SafetyDepositC3, winningConfigType, participationConfig, _yield$placeBid, placeBidTxId, bidderPotToken, _yield$Auction$load4, bidState, winIndex, hasWinner, _yield$redeemFullRigh, txId, _yield$redeemPrinting, _txId, _yield$claimBid, claimBidTxId, _yield$cancelBid, _txId2, hasWonParticipationPrize, _yield$redeemParticip, _txIds;\n\n    return _regeneratorRuntime.wrap(function _callee31$(_context31) {\n      while (1) {\n        switch (_context31.prev = _context31.next) {\n          case 0:\n            txIds = [];\n            _context31.next = 3;\n            return AuctionManager.getPDA(auction);\n\n          case 3:\n            auctionManagerPDA = _context31.sent;\n            _context31.next = 6;\n            return AuctionManager.load(connection, auctionManagerPDA);\n\n          case 6:\n            manager = _context31.sent;\n            _context31.next = 9;\n            return Vault.load(connection, manager.data.vault);\n\n          case 9:\n            vault = _context31.sent;\n            _context31.next = 12;\n            return AuctionExtended.getPDA(vault.pubkey);\n\n          case 12:\n            auctionExtendedPDA = _context31.sent;\n            _context31.next = 15;\n            return AuctionExtended.load(connection, auctionExtendedPDA);\n\n          case 15:\n            _yield$AuctionExtende = _context31.sent;\n            instantSalePrice = _yield$AuctionExtende.data.instantSalePrice;\n            _context31.next = 19;\n            return vault.getSafetyDepositBoxes(connection);\n\n          case 19:\n            _yield$vault$getSafet7 = _context31.sent;\n            _yield$vault$getSafet8 = _slicedToArray(_yield$vault$getSafet7, 1);\n            safetyDepositBox = _yield$vault$getSafet8[0];\n            _context31.next = 24;\n            return SafetyDepositConfig.getPDA(auctionManagerPDA, safetyDepositBox.pubkey);\n\n          case 24:\n            safetyDepositConfigPDA = _context31.sent;\n            _context31.next = 27;\n            return SafetyDepositConfig.load(connection, safetyDepositConfigPDA);\n\n          case 27:\n            _yield$SafetyDepositC2 = _context31.sent;\n            _yield$SafetyDepositC3 = _yield$SafetyDepositC2.data;\n            winningConfigType = _yield$SafetyDepositC3.winningConfigType;\n            participationConfig = _yield$SafetyDepositC3.participationConfig;\n            _context31.next = 33;\n            return placeBid({\n              connection: connection,\n              wallet: wallet,\n              amount: instantSalePrice,\n              auction: auction\n            });\n\n          case 33:\n            _yield$placeBid = _context31.sent;\n            placeBidTxId = _yield$placeBid.txId;\n            bidderPotToken = _yield$placeBid.bidderPotToken;\n            txIds.push(placeBidTxId);\n            _context31.next = 39;\n            return connection.confirmTransaction(placeBidTxId, 'finalized');\n\n          case 39:\n            _context31.next = 41;\n            return Auction.load(connection, auction);\n\n          case 41:\n            _yield$Auction$load4 = _context31.sent;\n            bidState = _yield$Auction$load4.data.bidState;\n            winIndex = bidState.getWinnerIndex(wallet.publicKey.toBase58());\n            hasWinner = winIndex !== null;\n\n            if (!hasWinner) {\n              _context31.next = 69;\n              break;\n            }\n\n            _context31.t0 = winningConfigType;\n            _context31.next = _context31.t0 === WinningConfigType.FullRightsTransfer ? 49 : _context31.t0 === WinningConfigType.PrintingV2 ? 55 : 61;\n            break;\n\n          case 49:\n            _context31.next = 51;\n            return redeemFullRightsTransferBid({\n              connection: connection,\n              wallet: wallet,\n              store: store,\n              auction: auction\n            });\n\n          case 51:\n            _yield$redeemFullRigh = _context31.sent;\n            txId = _yield$redeemFullRigh.txId;\n            txIds.push(txId);\n            return _context31.abrupt(\"break\", 62);\n\n          case 55:\n            _context31.next = 57;\n            return redeemPrintingV2Bid({\n              connection: connection,\n              wallet: wallet,\n              store: store,\n              auction: auction\n            });\n\n          case 57:\n            _yield$redeemPrinting = _context31.sent;\n            _txId = _yield$redeemPrinting.txId;\n            txIds.push(_txId);\n            return _context31.abrupt(\"break\", 62);\n\n          case 61:\n            throw new Error(\"\".concat(winningConfigType, \" winning type isn't supported yet\"));\n\n          case 62:\n            _context31.next = 64;\n            return claimBid({\n              connection: connection,\n              wallet: wallet,\n              store: store,\n              auction: auction,\n              bidderPotToken: bidderPotToken\n            });\n\n          case 64:\n            _yield$claimBid = _context31.sent;\n            claimBidTxId = _yield$claimBid.txId;\n            txIds.push(claimBidTxId);\n            _context31.next = 74;\n            break;\n\n          case 69:\n            _context31.next = 71;\n            return cancelBid({\n              connection: connection,\n              wallet: wallet,\n              auction: auction,\n              bidderPotToken: bidderPotToken\n            });\n\n          case 71:\n            _yield$cancelBid = _context31.sent;\n            _txId2 = _yield$cancelBid.txId;\n            txIds.push(_txId2);\n\n          case 74:\n            hasWonParticipationPrize = isEligibleForParticipationPrize(winIndex, participationConfig);\n\n            if (!hasWonParticipationPrize) {\n              _context31.next = 81;\n              break;\n            }\n\n            _context31.next = 78;\n            return redeemParticipationBidV3({\n              connection: connection,\n              wallet: wallet,\n              store: store,\n              auction: auction\n            });\n\n          case 78:\n            _yield$redeemParticip = _context31.sent;\n            _txIds = _yield$redeemParticip.txIds;\n\n            _txIds.push.apply(_txIds, _toConsumableArray(_txIds));\n\n          case 81:\n            return _context31.abrupt(\"return\", {\n              txIds: txIds\n            });\n\n          case 82:\n          case \"end\":\n            return _context31.stop();\n        }\n      }\n    }, _callee31);\n  }));\n};\n\nvar burnToken = function burnToken(_ref30) {\n  var connection = _ref30.connection,\n      wallet = _ref30.wallet,\n      token = _ref30.token,\n      mint = _ref30.mint,\n      amount = _ref30.amount,\n      owner = _ref30.owner,\n      _ref30$close = _ref30.close,\n      close = _ref30$close === void 0 ? true : _ref30$close;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee32() {\n    var tx, txId;\n    return _regeneratorRuntime.wrap(function _callee32$(_context32) {\n      while (1) {\n        switch (_context32.prev = _context32.next) {\n          case 0:\n            tx = new Transaction({\n              feePayer: wallet.publicKey\n            }).add(Token.createBurnInstruction(TOKEN_PROGRAM_ID, mint, token, owner !== null && owner !== void 0 ? owner : wallet.publicKey, [], amount));\n\n            if (close) {\n              tx.add(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, token, wallet.publicKey, owner !== null && owner !== void 0 ? owner : wallet.publicKey, []));\n            }\n\n            _context32.next = 4;\n            return sendTransaction({\n              connection: connection,\n              wallet: wallet,\n              txs: [tx]\n            });\n\n          case 4:\n            txId = _context32.sent;\n            return _context32.abrupt(\"return\", {\n              txId: txId\n            });\n\n          case 6:\n          case \"end\":\n            return _context32.stop();\n        }\n      }\n    }, _callee32);\n  }));\n};\n\nvar sendToken = function sendToken(_ref31) {\n  var connection = _ref31.connection,\n      wallet = _ref31.wallet,\n      source = _ref31.source,\n      destination = _ref31.destination,\n      mint = _ref31.mint,\n      amount = _ref31.amount;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee33() {\n    var txs, destAta, transactionCtorFields, txId;\n    return _regeneratorRuntime.wrap(function _callee33$(_context33) {\n      while (1) {\n        switch (_context33.prev = _context33.next) {\n          case 0:\n            txs = [];\n            _context33.next = 3;\n            return Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, mint, destination);\n\n          case 3:\n            destAta = _context33.sent;\n            transactionCtorFields = {\n              feePayer: wallet.publicKey\n            };\n            _context33.prev = 5;\n            _context33.next = 8;\n            return Account.load(connection, destAta);\n\n          case 8:\n            _context33.next = 13;\n            break;\n\n          case 10:\n            _context33.prev = 10;\n            _context33.t0 = _context33[\"catch\"](5);\n            txs.push(new CreateAssociatedTokenAccount(transactionCtorFields, {\n              associatedTokenAddress: destAta,\n              splTokenMintAddress: mint,\n              walletAddress: destination\n            }));\n\n          case 13:\n            txs.push(new Transaction(transactionCtorFields).add(Token.createTransferInstruction(TOKEN_PROGRAM_ID, source, destAta, wallet.publicKey, [], amount)));\n            _context33.next = 16;\n            return sendTransaction({\n              connection: connection,\n              wallet: wallet,\n              txs: txs\n            });\n\n          case 16:\n            txId = _context33.sent;\n            return _context33.abrupt(\"return\", {\n              txId: txId\n            });\n\n          case 18:\n          case \"end\":\n            return _context33.stop();\n        }\n      }\n    }, _callee33, null, [[5, 10]]);\n  }));\n};\n\nvar closeVault = function closeVault(_ref32) {\n  var connection = _ref32.connection,\n      wallet = _ref32.wallet,\n      vault = _ref32.vault,\n      priceMint = _ref32.priceMint;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee34() {\n    var accountRent, fractionMintAuthority, txBatch, txOptions, _yield$Vault$load, _yield$Vault$load$dat, fractionMint, fractionTreasury, redeemTreasury, pricingLookupAddress, fractionMintKey, fractionTreasuryKey, redeemTreasuryKey, pricingLookupAddressKey, activateVaultTx, outstandingShareAccount, outstandingShareAccountTx, payingTokenAccount, payingTokenAccountTx, transferAuthority, createApproveTx, combineVaultTx, txId;\n\n    return _regeneratorRuntime.wrap(function _callee34$(_context34) {\n      while (1) {\n        switch (_context34.prev = _context34.next) {\n          case 0:\n            _context34.next = 2;\n            return connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n\n          case 2:\n            accountRent = _context34.sent;\n            _context34.next = 5;\n            return Vault.getPDA(vault);\n\n          case 5:\n            fractionMintAuthority = _context34.sent;\n            txBatch = new TransactionsBatch({\n              transactions: []\n            });\n            txOptions = {\n              feePayer: wallet.publicKey\n            };\n            _context34.next = 10;\n            return Vault.load(connection, vault);\n\n          case 10:\n            _yield$Vault$load = _context34.sent;\n            _yield$Vault$load$dat = _yield$Vault$load.data;\n            fractionMint = _yield$Vault$load$dat.fractionMint;\n            fractionTreasury = _yield$Vault$load$dat.fractionTreasury;\n            redeemTreasury = _yield$Vault$load$dat.redeemTreasury;\n            pricingLookupAddress = _yield$Vault$load$dat.pricingLookupAddress;\n            fractionMintKey = new PublicKey(fractionMint);\n            fractionTreasuryKey = new PublicKey(fractionTreasury);\n            redeemTreasuryKey = new PublicKey(redeemTreasury);\n            pricingLookupAddressKey = new PublicKey(pricingLookupAddress);\n            activateVaultTx = new ActivateVault(txOptions, {\n              vault: vault,\n              numberOfShares: new BN(0),\n              fractionMint: fractionMintKey,\n              fractionTreasury: fractionTreasuryKey,\n              fractionMintAuthority: fractionMintAuthority,\n              vaultAuthority: wallet.publicKey\n            });\n            txBatch.addTransaction(activateVaultTx);\n            outstandingShareAccount = Keypair.generate();\n            outstandingShareAccountTx = new CreateTokenAccount(txOptions, {\n              newAccountPubkey: outstandingShareAccount.publicKey,\n              lamports: accountRent,\n              mint: fractionMintKey,\n              owner: wallet.publicKey\n            });\n            txBatch.addTransaction(outstandingShareAccountTx);\n            txBatch.addSigner(outstandingShareAccount);\n            payingTokenAccount = Keypair.generate();\n            payingTokenAccountTx = new CreateTokenAccount(txOptions, {\n              newAccountPubkey: payingTokenAccount.publicKey,\n              lamports: accountRent,\n              mint: priceMint,\n              owner: wallet.publicKey\n            });\n            txBatch.addTransaction(payingTokenAccountTx);\n            txBatch.addSigner(payingTokenAccount);\n            transferAuthority = Keypair.generate();\n\n            createApproveTx = function createApproveTx(account) {\n              return new Transaction().add(Token.createApproveInstruction(TOKEN_PROGRAM_ID, account.publicKey, transferAuthority.publicKey, wallet.publicKey, [], 0));\n            };\n\n            txBatch.addTransaction(createApproveTx(payingTokenAccount));\n            txBatch.addTransaction(createApproveTx(outstandingShareAccount));\n            txBatch.addSigner(transferAuthority);\n            combineVaultTx = new CombineVault(txOptions, {\n              vault: vault,\n              outstandingShareTokenAccount: outstandingShareAccount.publicKey,\n              payingTokenAccount: payingTokenAccount.publicKey,\n              fractionMint: fractionMintKey,\n              fractionTreasury: fractionTreasuryKey,\n              redeemTreasury: redeemTreasuryKey,\n              burnAuthority: fractionMintAuthority,\n              externalPriceAccount: pricingLookupAddressKey,\n              transferAuthority: transferAuthority.publicKey,\n              vaultAuthority: wallet.publicKey,\n              newVaultAuthority: wallet.publicKey\n            });\n            txBatch.addTransaction(combineVaultTx);\n            _context34.next = 39;\n            return sendTransaction({\n              connection: connection,\n              signers: txBatch.signers,\n              txs: txBatch.transactions,\n              wallet: wallet\n            });\n\n          case 39:\n            txId = _context34.sent;\n            return _context34.abrupt(\"return\", {\n              txId: txId\n            });\n\n          case 41:\n          case \"end\":\n            return _context34.stop();\n        }\n      }\n    }, _callee34);\n  }));\n};\n\nvar createExternalPriceAccount = function createExternalPriceAccount(_ref33) {\n  var connection = _ref33.connection,\n      wallet = _ref33.wallet;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee35() {\n    var txBatch, txOptions, epaRentExempt, externalPriceAccount, externalPriceAccountData, uninitializedEPA, updateEPA, txId;\n    return _regeneratorRuntime.wrap(function _callee35$(_context35) {\n      while (1) {\n        switch (_context35.prev = _context35.next) {\n          case 0:\n            txBatch = new TransactionsBatch({\n              transactions: []\n            });\n            txOptions = {\n              feePayer: wallet.publicKey\n            };\n            _context35.next = 4;\n            return connection.getMinimumBalanceForRentExemption(Vault.MAX_EXTERNAL_ACCOUNT_SIZE);\n\n          case 4:\n            epaRentExempt = _context35.sent;\n            externalPriceAccount = Keypair.generate();\n            externalPriceAccountData = new ExternalPriceAccountData({\n              pricePerShare: new BN(0),\n              priceMint: NATIVE_MINT.toBase58(),\n              allowedToCombine: true\n            });\n            uninitializedEPA = new Transaction().add(SystemProgram.createAccount({\n              fromPubkey: wallet.publicKey,\n              newAccountPubkey: externalPriceAccount.publicKey,\n              lamports: epaRentExempt,\n              space: Vault.MAX_EXTERNAL_ACCOUNT_SIZE,\n              programId: VaultProgram.PUBKEY\n            }));\n            txBatch.addTransaction(uninitializedEPA);\n            txBatch.addSigner(externalPriceAccount);\n            updateEPA = new UpdateExternalPriceAccount(txOptions, {\n              externalPriceAccount: externalPriceAccount.publicKey,\n              externalPriceAccountData: externalPriceAccountData\n            });\n            txBatch.addTransaction(updateEPA);\n            _context35.next = 14;\n            return sendTransaction({\n              connection: connection,\n              signers: txBatch.signers,\n              txs: txBatch.transactions,\n              wallet: wallet\n            });\n\n          case 14:\n            txId = _context35.sent;\n            return _context35.abrupt(\"return\", {\n              txId: txId,\n              externalPriceAccount: externalPriceAccount.publicKey,\n              priceMint: NATIVE_MINT\n            });\n\n          case 16:\n          case \"end\":\n            return _context35.stop();\n        }\n      }\n    }, _callee35);\n  }));\n};\n\nvar createVault = function createVault(_ref34) {\n  var connection = _ref34.connection,\n      wallet = _ref34.wallet,\n      _ref34$priceMint = _ref34.priceMint,\n      priceMint = _ref34$priceMint === void 0 ? NATIVE_MINT : _ref34$priceMint,\n      externalPriceAccount = _ref34.externalPriceAccount;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee36() {\n    var accountRent, mintRent, vaultRent, vault, vaultAuthority, txBatch, fractionMint, fractionMintTx, redeemTreasury, redeemTreasuryTx, fractionTreasury, fractionTreasuryTx, uninitializedVaultTx, initVaultTx, txId;\n    return _regeneratorRuntime.wrap(function _callee36$(_context36) {\n      while (1) {\n        switch (_context36.prev = _context36.next) {\n          case 0:\n            _context36.next = 2;\n            return connection.getMinimumBalanceForRentExemption(AccountLayout.span);\n\n          case 2:\n            accountRent = _context36.sent;\n            _context36.next = 5;\n            return connection.getMinimumBalanceForRentExemption(MintLayout.span);\n\n          case 5:\n            mintRent = _context36.sent;\n            _context36.next = 8;\n            return connection.getMinimumBalanceForRentExemption(Vault.MAX_VAULT_SIZE);\n\n          case 8:\n            vaultRent = _context36.sent;\n            vault = Keypair.generate();\n            _context36.next = 12;\n            return Vault.getPDA(vault.publicKey);\n\n          case 12:\n            vaultAuthority = _context36.sent;\n            txBatch = new TransactionsBatch({\n              transactions: []\n            });\n            fractionMint = Keypair.generate();\n            fractionMintTx = new CreateMint({\n              feePayer: wallet.publicKey\n            }, {\n              newAccountPubkey: fractionMint.publicKey,\n              lamports: mintRent,\n              owner: vaultAuthority,\n              freezeAuthority: vaultAuthority\n            });\n            txBatch.addTransaction(fractionMintTx);\n            txBatch.addSigner(fractionMint);\n            redeemTreasury = Keypair.generate();\n            redeemTreasuryTx = new CreateTokenAccount({\n              feePayer: wallet.publicKey\n            }, {\n              newAccountPubkey: redeemTreasury.publicKey,\n              lamports: accountRent,\n              mint: priceMint,\n              owner: vaultAuthority\n            });\n            txBatch.addTransaction(redeemTreasuryTx);\n            txBatch.addSigner(redeemTreasury);\n            fractionTreasury = Keypair.generate();\n            fractionTreasuryTx = new CreateTokenAccount({\n              feePayer: wallet.publicKey\n            }, {\n              newAccountPubkey: fractionTreasury.publicKey,\n              lamports: accountRent,\n              mint: fractionMint.publicKey,\n              owner: vaultAuthority\n            });\n            txBatch.addTransaction(fractionTreasuryTx);\n            txBatch.addSigner(fractionTreasury);\n            uninitializedVaultTx = new Transaction().add(SystemProgram.createAccount({\n              fromPubkey: wallet.publicKey,\n              newAccountPubkey: vault.publicKey,\n              lamports: vaultRent,\n              space: Vault.MAX_VAULT_SIZE,\n              programId: VaultProgram.PUBKEY\n            }));\n            txBatch.addTransaction(uninitializedVaultTx);\n            txBatch.addSigner(vault);\n            initVaultTx = new InitVault({\n              feePayer: wallet.publicKey\n            }, {\n              vault: vault.publicKey,\n              vaultAuthority: wallet.publicKey,\n              fractionalTreasury: fractionTreasury.publicKey,\n              pricingLookupAddress: externalPriceAccount,\n              redeemTreasury: redeemTreasury.publicKey,\n              fractionalMint: fractionMint.publicKey,\n              allowFurtherShareCreation: true\n            });\n            txBatch.addTransaction(initVaultTx);\n            _context36.next = 33;\n            return sendTransaction({\n              connection: connection,\n              signers: txBatch.signers,\n              txs: txBatch.transactions,\n              wallet: wallet\n            });\n\n          case 33:\n            txId = _context36.sent;\n            return _context36.abrupt(\"return\", {\n              txId: txId,\n              vault: vault.publicKey,\n              fractionMint: fractionMint.publicKey,\n              redeemTreasury: redeemTreasury.publicKey,\n              fractionTreasury: fractionTreasury.publicKey\n            });\n\n          case 35:\n          case \"end\":\n            return _context36.stop();\n        }\n      }\n    }, _callee36);\n  }));\n};\n\nvar initAuction = function initAuction(_ref35) {\n  var connection = _ref35.connection,\n      wallet = _ref35.wallet,\n      vault = _ref35.vault,\n      auctionSettings = _ref35.auctionSettings;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee37() {\n    var txOptions, _yield$Promise$all, _yield$Promise$all2, auctionKey, auctionExtended, fullSettings, auctionTx, txId;\n\n    return _regeneratorRuntime.wrap(function _callee37$(_context37) {\n      while (1) {\n        switch (_context37.prev = _context37.next) {\n          case 0:\n            txOptions = {\n              feePayer: wallet.publicKey\n            };\n            _context37.next = 3;\n            return Promise.all([Auction.getPDA(vault), AuctionExtended.getPDA(vault)]);\n\n          case 3:\n            _yield$Promise$all = _context37.sent;\n            _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n            auctionKey = _yield$Promise$all2[0];\n            auctionExtended = _yield$Promise$all2[1];\n            fullSettings = new CreateAuctionArgs(Object.assign(Object.assign({}, auctionSettings), {\n              authority: wallet.publicKey.toBase58(),\n              resource: vault.toBase58()\n            }));\n            auctionTx = new CreateAuction(txOptions, {\n              args: fullSettings,\n              auction: auctionKey,\n              creator: wallet.publicKey,\n              auctionExtended: auctionExtended\n            });\n            _context37.next = 11;\n            return sendTransaction({\n              connection: connection,\n              signers: [],\n              txs: [auctionTx],\n              wallet: wallet\n            });\n\n          case 11:\n            txId = _context37.sent;\n            return _context37.abrupt(\"return\", {\n              txId: txId,\n              auction: auctionKey\n            });\n\n          case 13:\n          case \"end\":\n            return _context37.stop();\n        }\n      }\n    }, _callee37);\n  }));\n};\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  addTokensToVault: addTokensToVault,\n  sendTransaction: sendTransaction,\n  initStore: initStore,\n  initStoreV2: initStoreV2,\n  mintNFT: mintNFT,\n  mintEditionFromMaster: mintEditionFromMaster,\n  createMetadata: createMetadata,\n  createMasterEdition: createMasterEdition,\n  signMetadata: signMetadata,\n  updateMetadata: updateMetadata,\n  cancelBid: cancelBid,\n  getCancelBidTransactions: getCancelBidTransactions,\n  placeBid: placeBid,\n  redeemFullRightsTransferBid: redeemFullRightsTransferBid,\n  getRedeemFRTBidTransactions: getRedeemFRTBidTransactions,\n  getBidRedemptionPDA: getBidRedemptionPDA,\n  redeemPrintingV2Bid: redeemPrintingV2Bid,\n  getRedeemPrintingV2BidTransactions: getRedeemPrintingV2BidTransactions,\n  getEditionOffset: getEditionOffset,\n  redeemParticipationBidV3: redeemParticipationBidV3,\n  isEligibleForParticipationPrize: isEligibleForParticipationPrize,\n  claimBid: claimBid,\n  getClaimBidTransactions: getClaimBidTransactions,\n  instantSale: instantSale,\n  burnToken: burnToken,\n  sendToken: sendToken,\n  prepareTokenAccountAndMintTxs: prepareTokenAccountAndMintTxs,\n  createWrappedAccountTxs: createWrappedAccountTxs,\n  createApproveTxs: createApproveTxs,\n  closeVault: closeVault,\n  createExternalPriceAccount: createExternalPriceAccount,\n  createVault: createVault,\n  initAuction: initAuction\n});\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  transactions: index$2,\n  auction: mplAuction,\n  core: mplCore,\n  metaplex: mplMetaplex,\n  metadata: mplTokenMetadata,\n  vault: mplTokenVault\n});\nexport { ArweaveStorage, ChainId, Coingecko, Connection, Currency, ENV, NodeWallet, index$1 as actions, index as programs, Storage$1 as storage, index$2 as transactions, index$3 as utils };","map":null,"metadata":{},"sourceType":"module"}